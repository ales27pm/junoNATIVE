# fastlane/Fastfile

default_platform(:ios)

require "tmpdir"
require "base64"
require "fileutils"
require "json"
require "shellwords"

ROOT_DIR = File.expand_path("..", __dir__)

############################################################
# Helpers
############################################################

def ensure_env!(vars)
  missing = vars.select { |v| ENV[v].to_s.empty? }
  UI.user_error!("Missing required environment variables: #{missing.join(", ")}") unless missing.empty?
end

# Resolve App Store Connect API key from:
# - APP_STORE_CONNECT_API_KEY_ID / APP_STORE_CONNECT_API_KEY_ISSUER_ID /
#   APP_STORE_CONNECT_API_KEY_BASE64 (base64 of .p8 content)
# OR
# - APP_STORE_CONNECT_API_KEY (raw .p8 content)
# OR fallback:
# - APPLE_KEY_ID / APPLE_ISSUER_ID / APPLE_KEY
def resolve_asc_config
  raw_key_id    = ENV["APP_STORE_CONNECT_API_KEY_ID"].to_s
  raw_issuer_id = ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"].to_s

  key_id    = raw_key_id.empty? ? ENV["APPLE_KEY_ID"].to_s : raw_key_id
  issuer_id = raw_issuer_id.empty? ? ENV["APPLE_ISSUER_ID"].to_s : raw_issuer_id

  key_base64 = ENV["APP_STORE_CONNECT_API_KEY_BASE64"].to_s
  key_raw    = (ENV["APP_STORE_CONNECT_API_KEY"].to_s.empty? ? ENV["APPLE_KEY"].to_s : ENV["APP_STORE_CONNECT_API_KEY"].to_s)

  UI.user_error!("Missing ASC key id / issuer id.") if key_id.empty? || issuer_id.empty?
  UI.user_error!("Missing ASC private key (.p8).") if key_base64.empty? && key_raw.empty?

  key_content = !key_base64.empty? ? Base64.decode64(key_base64) : key_raw

  {
    key_id: key_id,
    issuer_id: issuer_id,
    key_content: key_content
  }
end

def install_profile_from_base64!(profile_base64:, expected_team_id:, expected_bundle_id:)
  profiles_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
  FileUtils.mkdir_p(profiles_dir)

  tmp_profile = File.join(Dir.tmpdir, "profile#{Process.pid}-#{Time.now.to_i}.mobileprovision")
  File.binwrite(tmp_profile, Base64.decode64(profile_base64))

  decoded_plist = sh("security cms -D -i #{Shellwords.escape(tmp_profile)}", log: false)

  plist_path = File.join(Dir.tmpdir, "profile#{Process.pid}-#{Time.now.to_i}.plist")
  File.write(plist_path, decoded_plist)

  profile_uuid = sh("/usr/libexec/PlistBuddy -c 'Print :UUID' #{Shellwords.escape(plist_path)}", log: false).strip
  profile_name = sh("/usr/libexec/PlistBuddy -c 'Print :Name' #{Shellwords.escape(plist_path)}", log: false).strip
  team_id      = sh("/usr/libexec/PlistBuddy -c 'Print :TeamIdentifier:0' #{Shellwords.escape(plist_path)}", log: false).strip
  ent_app_id   = sh("/usr/libexec/PlistBuddy -c 'Print :Entitlements:application-identifier' #{Shellwords.escape(plist_path)}", log: false).strip

  UI.user_error!("Provisioning profile TeamID mismatch. Profile=#{team_id}, Expected=#{expected_team_id}") unless team_id == expected_team_id

  expected_full = "#{expected_team_id}.#{expected_bundle_id}"
  wildcard_full = "#{expected_team_id}.*"
  unless ent_app_id == expected_full || ent_app_id == wildcard_full
    UI.user_error!("Provisioning profile does not match APP_IDENTIFIER. Profile app-id=#{ent_app_id}, Expected #{expected_full} (or #{wildcard_full})")
  end

  installed_profile = File.join(profiles_dir, "#{profile_uuid}.mobileprovision")
  FileUtils.cp(tmp_profile, installed_profile)

  UI.success("‚úÖ Installed provisioning profile: #{profile_name} (#{profile_uuid})")
  { uuid: profile_uuid, name: profile_name, team_id: team_id, app_id: ent_app_id }
end

def find_apple_distribution_identity!
  out = sh("security find-identity -v -p codesigning", log: false)
  line = out.lines.find { |l| l.include?("Apple Distribution:") && l.include?("\"") }
  UI.user_error!("No 'Apple Distribution' signing identity found in keychain.") if line.nil?
  m = line.match(/"([^"]+)"/)
  UI.user_error!("Could not parse codesigning identity name from: #{line}") if m.nil?
  m[1]
end

def set_keychain_access_for_codesign!(keychain_path:, keychain_password:)
  # Avoid codesign prompts / failures on CI by allowing codesign + security tools.
  sh(%Q[
    security set-key-partition-list -S apple-tool:,apple:,codesign: -s \
      -k #{Shellwords.escape(keychain_password)} #{Shellwords.escape(keychain_path)} >/dev/null 2>&1
  ].gsub(/\s+/, " ").strip)
end

def ensure_archive_contains_app!(archive_path:)
  apps_dir = File.join(archive_path, "Products", "Applications")
  unless Dir.exist?(apps_dir)
    UI.user_error!("Archive is missing Products/Applications. This often means you archived a non-app scheme (generic archive). Verify the scheme archives the iOS app target.")
  end

  apps = Dir.glob(File.join(apps_dir, "*.app"))
  if apps.empty?
    UI.user_error!("Archive contains no .app in Products/Applications (generic archive). Check: shared scheme, Archive action builds the app target, SKIP_INSTALL=NO for app target.")
  end

  apps.first
end

def write_export_options_plist!(path:, team_id:, bundle_id:, profile_name:, method_value:)
  FileUtils.mkdir_p(File.dirname(path))

  # Write as a real XML plist (not JSON).
  # xcodebuild is picky; this stays deterministic.
  xml = <<~PLIST
    <?xml version="1.0" encoding="UTF-8"?>
    <!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
    <plist version="1.0">
    <dict>
      <key>signingStyle</key>
      <string>manual</string>

      <key>teamID</key>
      <string>#{team_id}</string>

      <key>method</key>
      <string>#{method_value}</string>

      <key>uploadSymbols</key>
      <true/>

      <key>uploadBitcode</key>
      <false/>

      <key>provisioningProfiles</key>
      <dict>
        <key>#{bundle_id}</key>
        <string>#{profile_name}</string>
      </dict>
    </dict>
    </plist>
  PLIST

  File.write(path, xml)
  UI.message("üßæ Wrote exportOptions.plist (method=#{method_value}) at #{path}")
end

def export_ipa_from_archive!(archive_path:, export_dir:, team_id:, bundle_id:, profile_name:)
  FileUtils.mkdir_p(export_dir)

  plist_path = File.join(Dir.tmpdir, "exportOptions#{Process.pid}-#{Time.now.to_i}.plist")

  # First attempt: app-store
  write_export_options_plist!(
    path: plist_path,
    team_id: team_id,
    bundle_id: bundle_id,
    profile_name: profile_name,
    method_value: "app-store"
  )

  cmd = %Q[
    xcodebuild -exportArchive
      -archivePath #{Shellwords.escape(archive_path)}
      -exportPath #{Shellwords.escape(export_dir)}
      -exportOptionsPlist #{Shellwords.escape(plist_path)}
  ].gsub(/\s+/, " ").strip

  UI.command(cmd)
  begin
    sh(cmd)
  rescue => e
    msg = e.to_s

    # Some toolchains (esp. newer) have been seen expecting app-store-connect.
    # If we see the classic "expected one {}" / method mismatch, retry once.
    if msg.include?("exportOptionsPlist error for key \"method\"") || msg.include?("expected one {}")
      UI.important("‚ö†Ô∏è Export failed with method=app-store. Retrying with method=app-store-connect‚Ä¶")

      write_export_options_plist!(
        path: plist_path,
        team_id: team_id,
        bundle_id: bundle_id,
        profile_name: profile_name,
        method_value: "app-store-connect"
      )

      cmd2 = %Q[
        xcodebuild -exportArchive
          -archivePath #{Shellwords.escape(archive_path)}
          -exportPath #{Shellwords.escape(export_dir)}
          -exportOptionsPlist #{Shellwords.escape(plist_path)}
      ].gsub(/\s+/, " ").strip

      UI.command(cmd2)
      sh(cmd2)
    else
      raise
    end
  end

  ipa = Dir.glob(File.join(export_dir, "*.ipa")).first
  UI.user_error!("Export finished but no IPA found in #{export_dir}") if ipa.nil?
  ipa
end

############################################################
# Lanes
############################################################

platform :ios do
  desc "CI pipeline: verify ASC, import cert, install profile (secret); archive; export IPA; upload TestFlight"
  lane :ios_ci do
    UI.header("üöÄ JunoNative iOS CI")

    verify_appstore_connect

    asc_api_key  = Actions.lane_context[:ASC_API_KEY]
    profile_name = Actions.lane_context[:PROFILE_NAME]

    team_id      = ENV["APPLE_TEAM_ID"]
    bundle_id    = ENV["APP_IDENTIFIER"]

    prepare_build_assets
    install_cocoapods
    compile_swift_sources

    codesign_identity = find_apple_distribution_identity!
    UI.message("üîè Using codesigning identity: #{codesign_identity}")

    archive_path = File.join(ROOT_DIR, "fastlane", "build", "ios", "JunoNative.xcarchive")
    export_dir   = File.join(ROOT_DIR, "fastlane", "build", "ios", "export")

    UI.message("üì¶ Archiving (gym) to #{archive_path} (no export yet)")

    # Archive only
    build_app(
      workspace: File.join("ios", "JunoNative.xcworkspace"),
      scheme: "JunoNative",
      configuration: "Release",
      sdk: "iphoneos",
      clean: true,

      archive_path: archive_path,
      skip_package_ipa: true,         # <‚Äî IMPORTANT: do NOT export here
      skip_profile_detection: true,

      codesigning_identity: codesign_identity,
      export_team_id: team_id,

      xcargs: [
        "DEVELOPMENT_TEAM=#{team_id}",
        "CODE_SIGN_STYLE=Manual",
        "PROVISIONING_PROFILE_SPECIFIER=#{Shellwords.escape(profile_name)}"
      ].join(" "),

      silent: false
    )

    UI.success("‚úÖ Archive created at #{archive_path}")

    # Validate it actually contains an app (prevents the ‚Äúexpected one {}‚Äù trap)
    app_path = ensure_archive_contains_app!(archive_path: archive_path)
    UI.success("‚úÖ Archive contains app: #{app_path}")

    UI.message("üì¶ Exporting IPA via xcodebuild -exportArchive")
    ipa_path = export_ipa_from_archive!(
      archive_path: archive_path,
      export_dir: export_dir,
      team_id: team_id,
      bundle_id: bundle_id,
      profile_name: profile_name
    )

    UI.success("‚úÖ IPA exported at #{ipa_path}")

    UI.message("üïä  Uploading to TestFlight")
    upload_to_testflight(
      ipa: ipa_path,
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      groups: ["Internal Testers"]
    )

    UI.success("üéâ TestFlight upload finished")
  end

  desc "Verify ASC API key; import distribution cert; install provisioning profile (from IOS_PROFILE_BASE64). No sigh."
  private_lane :verify_appstore_connect do
    UI.header("üîç Verifying ASC credentials, certificate & profile (ASC-only, no sigh)")

    ensure_env!([
      "APPLE_TEAM_ID",
      "APP_IDENTIFIER",
      "APP_STORE_CONNECT_API_KEY_ID",
      "APP_STORE_CONNECT_API_KEY_ISSUER_ID",
      "APP_STORE_CONNECT_API_KEY_BASE64",
      "IOS_DIST_CERT_BASE64",
      "IOS_DIST_CERT_PASSWORD",
      "IOS_PROFILE_BASE64"
    ])

    asc_cfg = resolve_asc_config

    api_key = app_store_connect_api_key(
      key_id: asc_cfg[:key_id],
      issuer_id: asc_cfg[:issuer_id],
      key_content: asc_cfg[:key_content],
      set_spaceship_token: true
    )

    # ‚úÖ IMPORTANT: do NOT assign Spaceship::ConnectAPI.token manually.
    # set_spaceship_token: true already wires the token correctly.
    Actions.lane_context[:ASC_API_KEY] = api_key

    # Sanity: fetch app by bundle id (filter)
    bundle_id = ENV["APP_IDENTIFIER"]
    apps = Spaceship::ConnectAPI::App.all(filter: { bundleId: bundle_id })
    app = apps.first
    UI.user_error!("App with identifier #{bundle_id} not found in this ASC account") if app.nil?
    UI.success("‚úÖ Authenticated ‚Äî Found app #{app.name} (#{app.bundle_id})")

    UI.header("üîê Verifying distribution certificate (.p12)")
    tmp_p12 = File.join(Dir.tmpdir, "dist#{Process.pid}-#{Time.now.to_i}.p12")
    File.binwrite(tmp_p12, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))

    sh("openssl pkcs12 -in #{Shellwords.escape(tmp_p12)} -nokeys -passin pass:#{Shellwords.escape(ENV['IOS_DIST_CERT_PASSWORD'])} -info >/dev/null 2>&1")
    UI.success("‚úÖ p12 structure and password are valid")

    keychain_name     = "ios-build.keychain-db"
    keychain_password = ENV["KEYCHAIN_PASSWORD"].to_s.empty? ? "fastlane_ci_temp" : ENV["KEYCHAIN_PASSWORD"]

    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    import_certificate(
      certificate_path: tmp_p12,
      certificate_password: ENV["IOS_DIST_CERT_PASSWORD"],
      keychain_name: keychain_name,
      keychain_password: keychain_password
    )

    keychain_path = File.expand_path("~/Library/Keychains/#{keychain_name}")
    set_keychain_access_for_codesign!(keychain_path: keychain_path, keychain_password: keychain_password)

    ENV["MATCH_KEYCHAIN_NAME"]     = keychain_name
    ENV["MATCH_KEYCHAIN_PASSWORD"] = keychain_password

    UI.header("üßæ Installing provisioning profile from IOS_PROFILE_BASE64")
    profile_meta = install_profile_from_base64!(
      profile_base64: ENV["IOS_PROFILE_BASE64"],
      expected_team_id: ENV["APPLE_TEAM_ID"],
      expected_bundle_id: bundle_id
    )

    Actions.lane_context[:PROFILE_UUID] = profile_meta[:uuid]
    Actions.lane_context[:PROFILE_NAME] = profile_meta[:name]

    UI.success("üéâ Verification completed (ASC + cert + profile).")
  end

  ############################################################
  # Build assets (your existing steps kept)
  ############################################################

  private_lane :compile_dsp_engine do
    UI.header("üéõ  Compiling DSP engine via CMake")
    build_dir = File.join(ROOT_DIR, "fastlane", "build", "cmake")
    sh("cmake -S #{Shellwords.escape(ROOT_DIR)} -B #{Shellwords.escape(build_dir)} -DCMAKE_BUILD_TYPE=Release")
    sh("cmake --build #{Shellwords.escape(build_dir)} --config Release")
    UI.success("‚úÖ DSP engine + tests compiled")
  end

  private_lane :compile_turbo_modules do
    UI.header("‚öôÔ∏è  TurboModules / Fabric codegen stub")
    codegen_build_dir = File.join(ROOT_DIR, "fastlane", "build", "codegen")
    FileUtils.mkdir_p(codegen_build_dir)
    UI.success("‚úÖ TurboModules stub completed")
  end

  private_lane :prepare_build_assets do
    UI.header("üß± Preparing build assets (DSP engine + TurboModules)")
    compile_dsp_engine
    compile_turbo_modules
  end

  private_lane :install_cocoapods do
    UI.header("üì¶ Installing CocoaPods dependencies")
    ios_dir = File.join(ROOT_DIR, "ios")
    Dir.chdir(ios_dir) { sh("bundle exec pod install --repo-update") }
    UI.success("‚úÖ Pods installed")
  end

  private_lane :compile_swift_sources do
    UI.header("üß™ Preflight Swift / RN build (no signing)")

    ws = File.join(ROOT_DIR, "ios", "JunoNative.xcworkspace")
    pr = File.join(ROOT_DIR, "ios", "JunoNative.xcodeproj")

    xcpretty = system("which xcpretty >/dev/null 2>&1")
    pretty   = xcpretty ? " | xcpretty --no-color" : ""

    common_flags = 'CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY=""'

    cmd =
      if File.exist?(ws)
        %Q[xcodebuild -workspace "#{ws}" -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' #{common_flags}]
      elsif File.exist?(pr)
        %Q[xcodebuild -project "#{pr}" -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' #{common_flags}]
      else
        UI.user_error!("No Xcode workspace or project found at ios/JunoNative.xcworkspace or ios/JunoNative.xcodeproj")
      end

    sh("set -o pipefail && #{cmd}#{pretty}")
    UI.success("‚úÖ Preflight build succeeded (no signing)")
  end
end
