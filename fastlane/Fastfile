require "fileutils"
require "base64"

ROOT_DIR = File.expand_path("..", __dir__)
IOS_OUTPUT_DIR = ENV.fetch("IOS_ARTIFACT_DIR", File.join(ROOT_DIR, "fastlane/build/ios"))
ANDROID_OUTPUT_DIR = ENV.fetch(
  "ANDROID_ARTIFACT_DIR",
  File.join(ROOT_DIR, "rtn-juno-engine/android/app/build/outputs/fastlane")
)
ANDROID_BUNDLE_ROOT = ENV.fetch(
  "ANDROID_BUNDLE_OUTPUT_DIR",
  File.join(ROOT_DIR, "rtn-juno-engine/android/app/build/outputs/bundle")
)
ANDROID_BUNDLE_PATH = ENV["ANDROID_RELEASE_BUNDLE_PATH"]
CMAKE_BUILD_DIR = ENV.fetch("CMAKE_BUILD_DIR", File.join(ROOT_DIR, "fastlane/build/cmake"))
CMAKE_CONFIGURATION = ENV.fetch("CMAKE_CONFIGURATION", "Release")
IOS_BUILD_CONFIGURATION = ENV.fetch("IOS_BUILD_CONFIGURATION", "Release")
IOS_BUILD_DESTINATION = ENV.fetch("IOS_BUILD_DESTINATION", "generic/platform=iOS Simulator")
IOS_SDK = ENV.fetch("IOS_SDK", "iphonesimulator")

def resolve_android_bundle(build_type)
  if ANDROID_BUNDLE_PATH
    resolved_bundle_path = File.expand_path(ANDROID_BUNDLE_PATH, ROOT_DIR)
    UI.user_error!("Explicit Android App Bundle not found at #{resolved_bundle_path}") unless File.exist?(resolved_bundle_path)
    return resolved_bundle_path
  end

  normalized_build_type = build_type.to_s
  normalized_build_type[0] = normalized_build_type[0].downcase if normalized_build_type.length.positive?

  candidate_directories = [
    normalized_build_type,
    build_type.to_s,
    build_type.to_s.downcase
  ].uniq

  kebab_build_type = build_type.to_s.gsub(/([a-z0-9])([A-Z])/, '\1-\2').downcase
  candidate_file_names = [
    "app-#{normalized_build_type}.aab",
    "app-#{build_type}.aab",
    "app-#{build_type.to_s.downcase}.aab",
    "app-#{kebab_build_type}.aab",
    "*.aab"
  ].uniq

  searched_dirs = []
  bundles = candidate_directories.flat_map do |dir|
    search_dir = File.join(ANDROID_BUNDLE_ROOT, dir)
    next [] unless Dir.exist?(search_dir)

    searched_dirs << search_dir

    candidate_file_names.flat_map do |file_pattern|
      Dir.glob(File.join(search_dir, file_pattern)).select { |path| File.file?(path) }
    end
  end

  UI.user_error!(
    "No Android App Bundle found. Checked directories: #{candidate_directories.map { |dir| File.join(ANDROID_BUNDLE_ROOT, dir) }.join(', ')}"
  ) if searched_dirs.empty?

  UI.user_error!(
    "No Android App Bundle found in searched directories: #{searched_dirs.join(', ')}"
  ) if bundles.empty?

  bundles.max_by { |path| File.mtime(path) }
end

def compile_cpp_engine
  FileUtils.mkdir_p(CMAKE_BUILD_DIR)

  sh("cmake -S #{ROOT_DIR} -B #{CMAKE_BUILD_DIR} -DCMAKE_BUILD_TYPE=#{CMAKE_CONFIGURATION}")
  sh("cmake --build #{CMAKE_BUILD_DIR} --config #{CMAKE_CONFIGURATION}")
end

def compile_swift_sources
  sh <<~CMD
    set -o pipefail && xcodebuild \
      -workspace ios/JunoNative.xcworkspace \
      -scheme JunoNative \
      -configuration #{IOS_BUILD_CONFIGURATION} \
      -sdk #{IOS_SDK} \
      -destination '#{IOS_BUILD_DESTINATION}' \
      CODE_SIGNING_ALLOWED=NO \
      build
  CMD
end

# Build a proper Hash for Fastlane's api_key parameter using a Base64-encoded p8 key
def app_store_api_key_hash
  require "base64"

  def app_store_api_key_hash
    decoded_key = Base64.decode64(ENV.fetch("APP_STORE_CONNECT_API_KEY_BASE64"))

    {
      key_id:   ENV.fetch("APP_STORE_CONNECT_API_KEY_ID"),
      issuer_id: ENV.fetch("APP_STORE_CONNECT_API_ISSUER_ID"),
      key:      decoded_key,
      in_house: false
    }
  end


default_platform(:ios)

platform :ios do
  desc "Build and upload to TestFlight"
  lane :release do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    sh("bash #{File.join(ROOT_DIR, 'scripts/compile-turbo-modules.sh')}")
    compile_swift_sources

    build_app(
      workspace: "ios/JunoNative.xcworkspace",
      scheme: "JunoNative",
      export_method: "app-store",
      output_directory: IOS_OUTPUT_DIR,
      output_name: ENV.fetch("IOS_OUTPUT_NAME", "JunoNative.ipa")
    )

    upload_to_testflight
  end

  desc "Build and upload iOS beta to TestFlight (App Store Connect API key, base64)"
  lane :beta do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    sh("bash #{File.join(ROOT_DIR, 'scripts/compile-turbo-modules.sh')}")
    compile_swift_sources

    api_key = app_store_api_key_hash

    build_app(
      workspace: "ios/JunoNative.xcworkspace",
      scheme: "JunoNativeApp",
      configuration: IOS_BUILD_CONFIGURATION,
      export_method: "app-store",
      destination: "generic/platform=iOS",
      output_directory: IOS_OUTPUT_DIR,
      output_name: ENV.fetch("IOS_OUTPUT_NAME", "JunoNative.ipa"),
      api_key: api_key
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end

  desc "CI lane: build and upload to TestFlight using App Store Connect API key (base64)"
  lane :ios_ci do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    sh("bash #{File.join(ROOT_DIR, 'scripts/compile-turbo-modules.sh')}")
    compile_swift_sources

    api_key = app_store_api_key_hash

    build_app(
      workspace: "ios/JunoNative.xcworkspace",
      scheme: "JunoNative",
      configuration: IOS_BUILD_CONFIGURATION,
      export_method: "app-store",
      destination: "generic/platform=iOS",
      output_directory: IOS_OUTPUT_DIR,
      output_name: ENV.fetch("IOS_OUTPUT_NAME", "JunoNative.ipa"),
      api_key: api_key
    )

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end
end

platform :android do
  desc "Build and upload to Play Console internal track"
  lane :release do |options|
    FileUtils.mkdir_p(ANDROID_OUTPUT_DIR)

    compile_cpp_engine
    sh("bash #{File.join(ROOT_DIR, 'scripts/compile-turbo-modules.sh')}")

    build_type = options[:build_type] || ENV.fetch("ANDROID_BUILD_TYPE", "Release")

    gradlew_path = File.join(ROOT_DIR, "rtn-juno-engine/android/gradlew")
    UI.user_error!("Gradle wrapper not found at #{gradlew_path}") unless File.exist?(gradlew_path)

    gradle(
      task: "bundle",
      build_type: build_type,
      project_dir: "rtn-juno-engine/android"
    )

    release_bundle = resolve_android_bundle(build_type)

    archived_bundle = File.join(
      ANDROID_OUTPUT_DIR,
      ENV.fetch("ANDROID_BUNDLE_NAME", File.basename(release_bundle))
    )
    FileUtils.cp(release_bundle, archived_bundle)

    upload_to_play_store(track: "internal", aab: archived_bundle)
  end
end
