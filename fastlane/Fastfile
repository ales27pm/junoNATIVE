default_platform(:ios)

require "tmpdir"
require "base64"
require "fileutils"
require "shellwords"

ROOT_DIR = File.expand_path("..", __dir__)

#######################
# Helper Methods
#######################
def env_any(*keys)
  keys.map { |k| ENV[k].to_s }.find { |v| !v.empty? } || ""
end

def ensure_any!(label, *keys)
  val = env_any(*keys)
  UI.user_error!("Missing #{label}. Provide one of: #{keys.join(', ')}") if val.empty?
  val
end

def resolve_asc_config
  key_id    = ensure_any!("ASC key id",            "APP_STORE_CONNECT_API_KEY_ID", "APPLE_KEY_ID")
  issuer_id = ensure_any!("ASC issuer id",         "APP_STORE_CONNECT_API_KEY_ISSUER_ID", "APPLE_ISSUER_ID")
  key_b64   = env_any("APP_STORE_CONNECT_API_KEY_BASE64")
  key_raw   = env_any("APP_STORE_CONNECT_API_KEY", "APPLE_KEY")
  UI.user_error!("Missing ASC private key. Provide APP_STORE_CONNECT_API_KEY_BASE64 or APP_STORE_CONNECT_API_KEY") if key_b64.empty? && key_raw.empty?

  content = key_b64.empty? ? key_raw : Base64.decode64(key_b64)
  { key_id: key_id, issuer_id: issuer_id, key_content: content }
end

def install_profile_from_base64!(b64, team_id, bundle_id)
  profiles_dir = File.expand_path("~/Library/MobileDevice/Provisioning Profiles")
  FileUtils.mkdir_p(profiles_dir)
  tmpf = File.join(Dir.tmpdir, "profile-#{Time.now.to_i}.mobileprovision")
  File.binwrite(tmpf, Base64.decode64(b64))

  plist = `security cms -D -i "#{tmpf}"`
  meta  = {
    uuid: `PlistBuddy -c 'Print :UUID' /dev/stdin <<< "#{plist}"`.strip,
    name: `PlistBuddy -c 'Print :Name' /dev/stdin <<< "#{plist}"`.strip,
  }
  FileUtils.cp(tmpf, File.join(profiles_dir, "#{meta[:uuid]}.mobileprovision"))
  UI.success("âœ… Installed provisioning profile: #{meta[:name]} (#{meta[:uuid]})")
  meta
end

def find_dist_identity!
  out = `security find-identity -v -p codesigning`
  line = out.lines.find { |l| l.include?("Apple Distribution:") && l =~ /"(.+)"/ }
  UI.user_error!("No Apple Distribution identity found") unless line
  line.match(/"(.+)"/)[1]
end

#######################
# Main CI Lane
#######################
platform :ios do
  desc "ðŸš€ Full CI: ASC-only cert/profile import â†’ patch project â†’ build & upload"
  lane :ios_ci do
    UI.header("ðŸ” 1. ASC auth + cert/profile import")
    asc = resolve_asc_config
    api_key = app_store_connect_api_key(
      key_id:     asc[:key_id],
      issuer_id:  asc[:issuer_id],
      key_content: asc[:key_content],
      set_spaceship_token: true
    )
    Actions.lane_context[:ASC_API_KEY] = api_key

    team_id    = ensure_any!("team id",        "APPLE_TEAM_ID")
    bundle_id  = ensure_any!("bundle id",      "APP_IDENTIFIER")
    p12_b64    = ensure_any!("p12 base64",     "IOS_DIST_CERT_BASE64", "IOS_CERT_P12_BASE64")
    p12_pw     = ensure_any!("p12 password",   "IOS_DIST_CERT_PASSWORD", "IOS_CERT_PASSWORD")
    prof_b64   = ensure_any!("profile base64", "IOS_PROFILE_BASE64", "IOS_PROVISIONING_PROFILE_BASE64")

    # import cert
    tmp_p12 = File.join(Dir.tmpdir, "dist-#{Time.now.to_i}.p12")
    File.binwrite(tmp_p12, Base64.decode64(p12_b64))
    sh("openssl pkcs12 -in #{Shellwords.escape(tmp_p12)} -nokeys -passin pass:#{Shellwords.escape(p12_pw)} >/dev/null")

    create_keychain(
      name: ENV["KEYCHAIN_NAME"] || "ios-build.keychain-db",
      password: ENV["KEYCHAIN_PASSWORD"] || "fastlane_ci",
      default_keychain: true, unlock: true, timeout: 3600
    )
    import_certificate(
      certificate_path: tmp_p12,
      certificate_password: p12_pw,
      keychain_name: ENV["KEYCHAIN_NAME"] || "ios-build.keychain-db"
    )
    sh("security set-key-partition-list -S apple-tool:,apple: -s -k #{Shellwords.escape(ENV['KEYCHAIN_PASSWORD']||'fastlane_ci')} ~/Library/Keychains/ios-build.keychain-db")

    # import profile
    meta = install_profile_from_base64!(prof_b64, team_id, bundle_id)
    Actions.lane_context[:PROFILE_NAME] = meta[:name]

    UI.header("ðŸ§° 2. Patch Xcode project & scheme")
    fix_xcodeproj_settings
    ensure_shared_scheme

    UI.header("ðŸ“¦ 3. Build Archive + Export IPA")
    codesign_id = find_dist_identity!
    signing_args = [
      "DEVELOPMENT_TEAM=#{team_id}",
      "CODE_SIGN_STYLE=Manual",
      "CODE_SIGN_IDENTITY=#{Shellwords.escape(codesign_id)}",
      "PROVISIONING_PROFILE_SPECIFIER=#{Shellwords.escape(meta[:name])}"
    ].join(" ")

    ipa = build_app(
      workspace:      "ios/JunoNative.xcworkspace",
      scheme:         "JunoNative",
      clean:          true,
      export_method:  "app-store",
      skip_profile_detection: true,
      export_team_id: team_id,
      export_options: {
        signingStyle: "manual",
        teamID:       team_id,
        provisioningProfiles: { bundle_id => meta[:name] }
      },
      output_directory: "fastlane/build/ios",
      output_name:      "JunoNative.ipa",
      xcargs:           signing_args
    )
    UI.success("âœ… IPA built at: #{ipa}")

    UI.header("ðŸ•Š 4. Upload to TestFlight")
    upload_to_testflight(
      ipa: ipa,
      api_key: api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false
    )
    UI.success("ðŸŽ‰ Done!")
  end

  ########################
  # Support Lanes
  ########################
  private_lane :fix_xcodeproj_settings do
    UI.header("Patching XcodeProj to generate a real .app archive")
    sh("bundle exec ruby scripts/ci/fix_xcodeproj.rb")
  end

  private_lane :ensure_shared_scheme do
    UI.header("Ensuring JunoNative scheme is shared & builds the app target")
    sh("bundle exec ruby scripts/ci/ensure_shared_scheme.rb ios/JunoNative.xcodeproj JunoNative")
  end
end
