default_platform(:ios)

require "tmpdir"
require "base64"

# Root of the repo (Fastfile lives in fastlane/)
ROOT_DIR = File.expand_path("..", __dir__)

############################################################
# Helpers
############################################################

def ensure_env!(vars)
  missing = vars.select { |v| ENV[v].to_s.empty? }
  unless missing.empty?
    UI.user_error!("Missing required environment variables: #{missing.join(", ")}")
  end
end

# Resolve App Store Connect API key from multiple possible env layouts:
# - APP_STORE_CONNECT_API_KEY_ID / APP_STORE_CONNECT_API_KEY_ISSUER_ID /
#   APP_STORE_CONNECT_API_KEY_BASE64 (base64 of .p8)
# - or APP_STORE_CONNECT_API_KEY_ID / APP_STORE_CONNECT_API_KEY_ISSUER_ID /
#   APP_STORE_CONNECT_API_KEY (raw .p8 content)
# - or APPLE_KEY_ID / APPLE_ISSUER_ID / APPLE_KEY (raw .p8)
def resolve_asc_config
  key_id    = ENV["APP_STORE_CONNECT_API_KEY_ID"]         || ENV["APPLE_KEY_ID"]
  issuer_id = ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"]  || ENV["APPLE_ISSUER_ID"]

  key_base64 = ENV["APP_STORE_CONNECT_API_KEY_BASE64"]
  key_raw    = ENV["APP_STORE_CONNECT_API_KEY"] || ENV["APPLE_KEY"]

  if key_id.to_s.empty? || issuer_id.to_s.empty?
    UI.user_error!("Missing ASC key id / issuer id. Provide either:
      - APP_STORE_CONNECT_API_KEY_ID and APP_STORE_CONNECT_API_KEY_ISSUER_ID
      or
      - APPLE_KEY_ID and APPLE_ISSUER_ID (which map to the same values)."
    )
  end

  if key_base64.to_s.empty? && key_raw.to_s.empty?
    UI.user_error!("Missing ASC private key. Provide either:
      - APP_STORE_CONNECT_API_KEY_BASE64 (base64-encoded .p8 contents)
      or
      - APP_STORE_CONNECT_API_KEY / APPLE_KEY (raw .p8 contents)."
    )
  end

  key_content =
    if !key_base64.to_s.empty?
      Base64.decode64(key_base64)
    else
      key_raw
    end

  {
    key_id: key_id,
    issuer_id: issuer_id,
    key_content: key_content
  }
end

platform :ios do
  ############################################################
  # Main CI lane
  ############################################################
  desc "CI pipeline: verify ASC, build DSP, pods, preflight build, archive + TestFlight"
  lane :ios_ci do
    UI.header("ðŸš€ JunoNative iOS CI")

    # 1) Verify ASC, certs, profiles and stash the api_key in lane_context
    verify_appstore_connect

    # Grab the api_key produced by verify_appstore_connect
    asc_api_key = Actions.lane_context[:ASC_API_KEY]

    # 2) Build native assets and pods
    prepare_build_assets
    install_cocoapods

    # 3) Preflight compile (no signing, just "does it build?")
    compile_swift_sources

    UI.message("ðŸ“¦ Building archive + IPA with gym")

    ios_build_options = {
      workspace: File.join("ios", "JunoNative.xcworkspace"),
      scheme: "JunoNative",
      configuration: "Release",
      sdk: "iphoneos",
      clean: true,

      # Signing/export
      export_method: "app-store", # let gym generate exportOptionsPlist itself
      api_key: asc_api_key,       # reuse the same ASC key for gym

      # Output
      output_directory: File.join("fastlane", "build", "ios"),
      output_name: "JunoNative.ipa",

      # Helpful flags
      include_symbols: true,
      include_bitcode: false,
      silent: false,
      skip_profile_detection: false,

      # Pass team ID into xcodebuild
      xcargs: "DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']}"
    }

    ipa_path = build_app(ios_build_options)

    UI.success("âœ… IPA built at #{ipa_path}")

    UI.message("ðŸ•Š  Uploading to TestFlight")

    upload_to_testflight(
      ipa: ipa_path,
      api_key: asc_api_key,
      skip_waiting_for_build_processing: true,
      distribute_external: false,
      groups: ["Internal Testers"]
    )

    UI.success("ðŸŽ‰ TestFlight upload finished")
  end

  ############################################################
  # 1. Verify ASC + cert + profile
  ############################################################
  desc "Verify App Store Connect API key, distribution certificate and provisioning profile"
  private_lane :verify_appstore_connect do
    UI.header("ðŸ” Verifying ASC credentials, certificate & profile")

    # These are always required
    ensure_env!([
      "APPLE_ID",
      "APPLE_TEAM_ID",
      "APP_IDENTIFIER",
      "IOS_DIST_CERT_BASE64",
      "IOS_DIST_CERT_PASSWORD"
    ])

    # ---- ASC API key (flexible env resolution) ----
    UI.message("ðŸ”‘ Resolving App Store Connect API key configuration")
    asc_cfg = resolve_asc_config

    UI.message("ðŸ”‘ Creating App Store Connect API key")
    api_key = app_store_connect_api_key(
      key_id: asc_cfg[:key_id],
      issuer_id: asc_cfg[:issuer_id],
      key_content: asc_cfg[:key_content]
    )

    # Make api_key available to other lanes
    Actions.lane_context[:ASC_API_KEY] = api_key

    # Quick sanity: list apps to prove credentials work
    apps = Spaceship::ConnectAPI::App.all(client: api_key)
    UI.success("âœ… Authenticated â€” #{apps.count} apps in this account")

    app_identifier = ENV["APP_IDENTIFIER"]
    app = apps.find { |a| a.bundle_id == app_identifier }

    if app.nil?
      UI.user_error!("App with identifier #{app_identifier} not found in this ASC account")
    else
      UI.success("âœ… Found app #{app.name} (#{app.bundle_id})")
    end

    # ---- Decode and verify .p12 ----
    UI.header("ðŸ” Verifying distribution certificate (.p12)")

    tmp_p12 = File.join(Dir.tmpdir, "dist#{Process.pid}-#{Time.now.to_i}.p12")
    File.binwrite(tmp_p12, Base64.decode64(ENV["IOS_DIST_CERT_BASE64"]))

    UI.command("openssl pkcs12 -in '#{tmp_p12}' -nokeys -passin pass:*** -info >/dev/null 2>&1")
    sh("openssl pkcs12 -in '#{tmp_p12}' -nokeys -passin pass:#{ENV['IOS_DIST_CERT_PASSWORD']} -info >/dev/null 2>&1")

    UI.success("âœ… p12 structure and password are valid")

    # ---- Create / configure keychain & import cert ----
    keychain_name     = "ios-build.keychain-db"
    keychain_password = ENV["KEYCHAIN_PASSWORD"].to_s.empty? ? "fastlane_ci_temp" : ENV["KEYCHAIN_PASSWORD"]

    UI.message("ðŸ” Creating CI keychain #{keychain_name}")

    create_keychain(
      name: keychain_name,
      password: keychain_password,
      default_keychain: true,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    import_certificate(
      certificate_path: tmp_p12,
      certificate_password: ENV["IOS_DIST_CERT_PASSWORD"],
      keychain_name: keychain_name
    )

    ENV["MATCH_KEYCHAIN_NAME"]     = keychain_name
    ENV["MATCH_KEYCHAIN_PASSWORD"] = keychain_password

    # ---- Provisioning profile via sigh ----
    UI.header("ðŸ§¾ Verifying provisioning profile via sigh")

    profile_path = sigh(
      app_identifier: app_identifier,
      api_key: api_key,
      skip_install: true,
      readonly: false,
      adhoc: false,
      developer_id: false,
      development: false,
      platform: "ios",
      fail_on_name_taken: false
    )

    UI.success("âœ… Provisioning profile downloaded: #{profile_path}")

    ENV["SIGH_PROFILE_PATH"]  = profile_path
    ENV["SIGH_PROFILE_PATHS"] = [profile_path].to_json
    ENV["SIGH_PROFILE_TYPE"]  = "app-store"

    UI.success("ðŸŽ‰ Verification completed.")
  end

  ############################################################
  # 2. Build DSP core (CMake)
  ############################################################
  desc "Compile the C++ DSP engine via CMake"
  private_lane :compile_dsp_engine do
    UI.header("ðŸŽ›  Compiling DSP engine via CMake")

    build_dir = File.join(ROOT_DIR, "fastlane", "build", "cmake")
    sh("cmake -S #{ROOT_DIR} -B #{build_dir} -DCMAKE_BUILD_TYPE=Release")
    sh("cmake --build #{build_dir} --config Release")

    UI.success("âœ… DSP engine + tests compiled")
  end

  ############################################################
  # 3. TurboModules / codegen placeholder (deterministic)
  ############################################################
  desc "Compile TurboModules / Fabric â€“ delegated to RN Xcode build phases, but we keep a deterministic step in CI"
  private_lane :compile_turbo_modules do
    UI.header("âš™ï¸  TurboModules / Fabric codegen stub")

    UI.message("[codegen] =====================================================")
    UI.message("[codegen] TurboModule / Fabric codegen is handled by React Native's")
    UI.message("[codegen] own Xcode/Pods build phases.")
    UI.message("[codegen] Skipping standalone codegen step in CI.")
    UI.message("[codegen] This script exists only so the Fastlane lane")
    UI.message("[codegen] :compile_turbo_modules has a successful, deterministic step.")
    UI.message("[codegen] =====================================================")

    codegen_build_dir = File.join(ROOT_DIR, "fastlane", "fastlane", "build", "codegen")
    FileUtils.mkdir_p(codegen_build_dir)
    UI.message("[codegen] Ensured codegen build directory exists at: #{codegen_build_dir}")

    UI.success("âœ… TurboModules stub completed")
  end

  ############################################################
  # 4. Prepare build assets (DSP + codegen)
  ############################################################
  desc "Prepare build assets: DSP engine + TurboModules / codegen"
  private_lane :prepare_build_assets do
    UI.header("ðŸ§± Preparing build assets (DSP engine + TurboModules)")
    compile_dsp_engine
    compile_turbo_modules
  end

  ############################################################
  # 5. CocoaPods install
  ############################################################
  desc "Install CocoaPods dependencies with repo update"
  private_lane :install_cocoapods do
    UI.header("ðŸ“¦ Installing CocoaPods dependencies")

    ios_dir = File.join(ROOT_DIR, "ios")
    Dir.chdir(ios_dir) do
      sh("bundle exec pod install --repo-update")
    end

    UI.success("âœ… Pods installed")
  end

  ############################################################
  # 6. Preflight Swift / RN build (no signing)
  ############################################################
  desc "Preflight compile of Swift / RN sources for device (no signing)"
  private_lane :compile_swift_sources do
    UI.header("ðŸ§ª Preflight Swift / RN build (no signing)")

    ws = File.join(ROOT_DIR, "ios", "JunoNative.xcworkspace")
    pr = File.join(ROOT_DIR, "ios", "JunoNative.xcodeproj")

    xcpretty = system("which xcpretty >/dev/null 2>&1")
    pretty   = xcpretty ? " | xcpretty --no-color" : ""

    # IMPORTANT:
    # - We *disable* signing here so Pods static libraries don't try to sign
    #   with an "empty identity".
    # - Real signing is done later by `build_app` / gym during archive.
    common_flags = 'CODE_SIGNING_ALLOWED=NO CODE_SIGNING_REQUIRED=NO CODE_SIGN_IDENTITY=""'

    cmd =
      if File.exist?(ws)
        %Q[
          xcodebuild
            -workspace "#{ws}"
            -scheme JunoNative
            -configuration Release
            -sdk iphoneos
            -destination 'generic/platform=iOS'
            #{common_flags}
        ].gsub(/\s+/, " ").strip
      elsif File.exist?(pr)
        %Q[
          xcodebuild
            -project "#{pr}"
            -scheme JunoNative
            -configuration Release
            -sdk iphoneos
            -destination 'generic/platform=iOS'
            #{common_flags}
        ].gsub(/\s+/, " ").strip
      else
        UI.user_error!("No Xcode workspace or project found at ios/JunoNative.xcworkspace or ios/JunoNative.xcodeproj")
      end

    UI.command("set -o pipefail && #{cmd}#{pretty}")
    sh("set -o pipefail && #{cmd}#{pretty}")

    UI.success("âœ… Preflight build succeeded (no signing)")
  end
end
