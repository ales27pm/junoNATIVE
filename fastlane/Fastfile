# frozen_string_literal: true
# fastlane/Fastfile
require "plist"
require "base64"
require "tempfile"
require "securerandom"

default_platform(:ios)

ROOT_DIR = File.expand_path("..", __dir__)
ENV["SPACESHIP_CONNECT_API_IN_HOUSE"] ||= "false"

# -------------------------------------------------
# üîë  Build App Store Connect API-key hash
# -------------------------------------------------
def app_store_api_key_hash
  api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
  issuer_id  = ENV["APP_STORE_CONNECT_API_ISSUER_ID"] ||
               ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"]
  key_base64 = ENV["APP_STORE_CONNECT_API_KEY_BASE64"]
  raw_key    = ENV["APP_STORE_CONNECT_API_KEY"]

  UI.user_error!("APP_STORE_CONNECT_API_KEY_ID and ‚Ä¶_ISSUER_ID must be set") \
    if api_key_id.to_s.empty? || issuer_id.to_s.empty?
  UI.user_error!("Either ‚Ä¶_KEY_BASE64 or ‚Ä¶_KEY must be set") \
    if key_base64.to_s.empty? && raw_key.to_s.empty?

  {
    key_id:    api_key_id,
    issuer_id: issuer_id,
    key:       key_base64.to_s.empty? ? raw_key : Base64.decode64(key_base64),
    in_house:  false
  }
end

# -------------------------------------------------
# üì¶  Shared Xcode build options
# -------------------------------------------------
def ios_build_options
  workspace_path = File.join(ROOT_DIR, "ios", "JunoNative.xcworkspace")
  project_path   = File.join(ROOT_DIR, "ios", "JunoNative.xcodeproj")
  export_plist   = File.join(ROOT_DIR, "ios", "exportOptions.plist")

  has_ws = File.exist?(workspace_path)
  has_pr = File.exist?(project_path)
  UI.user_error!("No .xcworkspace or .xcodeproj in ios/") unless has_ws || has_pr
  UI.user_error!("exportOptions.plist missing in ios/")   unless File.exist?(export_plist)

  plist = Plist.parse_xml(export_plist) || {}
  plist["teamID"] = ENV["APPLE_TEAM_ID"] unless ENV["APPLE_TEAM_ID"].to_s.empty?

  profile_name   = ENV["IOS_PROVISIONING_PROFILE_NAME"]
  app_identifier = ENV["APP_IDENTIFIER"]
  if profile_name.to_s.empty?
    plist["signingStyle"] = "automatic"
  else
    UI.user_error!("APP_IDENTIFIER missing while profile set") if app_identifier.to_s.empty?
    plist["signingStyle"] = "manual"
    plist["provisioningProfiles"] ||= {}
    plist["provisioningProfiles"][app_identifier] = profile_name
  end

  {
    workspace:         has_ws ? workspace_path : nil,
    project:           has_ws ? nil            : project_path,
    scheme:            "JunoNative",
    configuration:     "Release",
    clean:             true,
    output_directory:  File.join(ROOT_DIR, "fastlane", "build", "ios"),
    output_name:       ENV["IOS_OUTPUT_NAME"] || "JunoNative.ipa",
    export_options:    plist,
    result_bundle:     true,
    buildlog_path:     File.join(ROOT_DIR, "fastlane", "logs"),
    export_xcargs:     "DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']}"
  }.compact
end

# =================================================
# üöÄ  Lanes
# =================================================
platform :ios do
  # ---------- helpers ----------
  private_lane :install_cocoapods do
    ios_dir = File.join(ROOT_DIR, "ios")
    UI.user_error!("Podfile missing") unless File.exist?(File.join(ios_dir, "Podfile"))
    Dir.chdir(ios_dir) { sh("bundle exec pod install --repo-update") }
  end

  private_lane :compile_swift_sources do
    ws = File.join(ROOT_DIR, "ios", "JunoNative.xcworkspace")
    pr = File.join(ROOT_DIR, "ios", "JunoNative.xcodeproj")
    xcpretty = system("which xcpretty >/dev/null 2>&1")
    pretty   = xcpretty ? " | xcpretty --no-color" : ""
    cmd = if File.exist?(ws)
            %Q[xcodebuild -workspace "#{ws}" -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' CODE_SIGNING_ALLOWED=NO build]
          else
            %Q[xcodebuild -project "#{pr}"  -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' CODE_SIGNING_ALLOWED=NO build]
          end
    sh("set -o pipefail && #{cmd}#{pretty}")
  end

  # -------------------------------------------------
  # üîç  Verification (API key + p12 + profile)
  # -------------------------------------------------
  desc "Verify ASC credentials, p12 & provisioning profile"
  lane :verify_appstore_connect do
    UI.header("üîç Verifying ASC credentials, certificate & profile")
    %w[APPLE_ID APP_IDENTIFIER APPLE_TEAM_ID APP_STORE_CONNECT_API_KEY_ID
       APP_STORE_CONNECT_API_ISSUER_ID APP_STORE_CONNECT_API_KEY_BASE64
       IOS_DIST_CERT_BASE64 IOS_DIST_CERT_PASSWORD].each { |v| UI.user_error!("Missing #{v}") if ENV[v].to_s.empty? }

    api_key = app_store_api_key_hash
    require "spaceship"
    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(**api_key)

    apps = Spaceship::ConnectAPI::App.all
    UI.success("‚úÖ Authenticated ‚Äî #{apps.size} apps in account")
    if (bid = ENV["APP_IDENTIFIER"]).to_s != ""
      apps.find { |a| a.bundle_id == bid } \
        ? UI.success("‚úÖ App #{bid} exists in ASC") \
        : UI.important("‚ö†Ô∏è  No ASC app with bundle id #{bid}")
    end

    # ---------- certificate ----------
    UI.header("üîê Validating p12 certificate")
    decoded_p12 = Base64.decode64(ENV["IOS_DIST_CERT_BASE64"])
    UI.user_error!("Decoded p12 is empty") if decoded_p12.empty?

    keychain_name = "fastlane_tmp_#{SecureRandom.hex(4)}.keychain"
    keychain_pw   = "fastlane"

    create_keychain(
      name: keychain_name,
      password: keychain_pw,
      default_keychain: false,
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false
    )

    Tempfile.create(["cert", ".p12"]) do |tmp|
      tmp.binmode; tmp.write(decoded_p12); tmp.flush
      sh("openssl pkcs12 -in '#{tmp.path}' -nokeys -passin pass:#{ENV['IOS_DIST_CERT_PASSWORD']} -info >/dev/null 2>&1")
      import_certificate(
        keychain_path:     File.expand_path("~/Library/Keychains/#{keychain_name}"),
        keychain_password: keychain_pw,
        certificate_path:  tmp.path,
        certificate_password: ENV["IOS_DIST_CERT_PASSWORD"]
      )
    end
    UI.success("‚úÖ p12 imported into #{keychain_name}")

    # ---------- provisioning profile ----------
    UI.header("üßæ Fetching/creating provisioning profile via sigh")
    profile_path = sigh(
      app_identifier: ENV["APP_IDENTIFIER"],
      api_key:        api_key,
      adhoc:          false,
      readonly:       false,
      skip_install:   true
    ) || Actions.lane_context[SharedValues::SIGH_PROFILE_PATH]

    profile_name = File.basename(profile_path, ".mobileprovision")
    UI.success("‚úÖ Provisioning profile OK: #{profile_name}")

    UI.success("üéâ Full validation successful")
  ensure
    delete_keychain(name: keychain_name) if keychain_name
  end

  # -------------------------------------------------
  # üéÅ  CI / TestFlight lane
  # -------------------------------------------------
  desc "CI: build and upload to TestFlight"
  lane :ios_ci do
    verify_appstore_connect

    ENV["IOS_PROVISIONING_PROFILE_NAME"] = File.basename(
      Actions.lane_context[SharedValues::SIGH_PROFILE_PATH], ".mobileprovision"
    )

    install_cocoapods
    compile_swift_sources
    build_app(ios_build_options)

    upload_to_testflight(
      api_key:            app_store_api_key_hash,
      app_identifier:     ENV["APP_IDENTIFIER"],
      team_id:            ENV["APPLE_TEAM_ID"],
      skip_waiting_for_build_processing: false,
      distribute_external: false
    )
  end
end
