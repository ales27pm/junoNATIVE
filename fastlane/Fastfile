# frozen_string_literal: true
require 'plist'
require 'base64'
require 'tempfile'
require 'securerandom'

default_platform :ios
ROOT_DIR = File.expand_path('..', __dir__)
ENV['SPACESHIP_CONNECT_API_IN_HOUSE'] ||= 'false'

# -------------------------------
# üîë  Build ASC API-key hash
# -------------------------------
def app_store_api_key_hash
  api_key_id = ENV.fetch('APP_STORE_CONNECT_API_KEY_ID')
  issuer_id  = ENV['APP_STORE_CONNECT_API_ISSUER_ID'] || ENV['APP_STORE_CONNECT_API_KEY_ISSUER_ID']
  key_b64    = ENV['APP_STORE_CONNECT_API_KEY_BASE64']
  raw_key    = ENV['APP_STORE_CONNECT_API_KEY']

  UI.user_error!('Provide APP_STORE_CONNECT_API_ISSUER_ID') if issuer_id.to_s.empty?
  UI.user_error!('Either ‚Ä¶KEY_BASE64 or ‚Ä¶KEY must be set')  if key_b64.to_s.empty? && raw_key.to_s.empty?

  {
    key_id:    api_key_id,
    issuer_id: issuer_id,
    key:       key_b64.to_s.empty? ? raw_key : Base64.decode64(key_b64),
    in_house:  false
  }
end

# -------------------------------
# üîß  Shared Xcode build opts
# -------------------------------
def ios_build_options
  ws = File.join(ROOT_DIR, 'ios', 'JunoNative.xcworkspace')
  pr = File.join(ROOT_DIR, 'ios', 'JunoNative.xcodeproj')
  UI.user_error!('No workspace/project in ios/') unless File.exist?(ws) || File.exist?(pr)

  exp_plist = File.join(ROOT_DIR, 'ios', 'exportOptions.plist')
  UI.user_error!("Missing #{exp_plist}") unless File.exist?(exp_plist)
  plist      = Plist.parse_xml(exp_plist) || {}
  plist['teamID'] = ENV['APPLE_TEAM_ID'] unless ENV['APPLE_TEAM_ID'].to_s.empty?

  prof_name = ENV['IOS_PROVISIONING_PROFILE_NAME']
  bundle_id = ENV['APP_IDENTIFIER']
  if prof_name.to_s.empty?
    plist['signingStyle'] = 'automatic'
  else
    UI.user_error!('APP_IDENTIFIER missing') if bundle_id.to_s.empty?
    plist['signingStyle'] = 'manual'
    plist['provisioningProfiles'] ||= {}
    plist['provisioningProfiles'][bundle_id] = prof_name
  end

  {
    workspace:   File.exist?(ws) ? ws : nil,
    project:     File.exist?(ws) ? nil : pr,
    scheme:      'JunoNative',
    configuration: 'Release',
    clean:         true,
    output_directory: File.join(ROOT_DIR, 'fastlane', 'build', 'ios'),
    output_name:      ENV['IOS_OUTPUT_NAME'] || 'JunoNative.ipa',
    export_options:   plist,
    result_bundle:    true,
    buildlog_path:    File.join(ROOT_DIR, 'fastlane', 'logs'),
    export_xcargs:    "DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']}"
  }.compact
end

# -------------------------------------------------------------------
# üöÄ  Lanes
# -------------------------------------------------------------------
platform :ios do
  # ---------- Helpers ----------
  private_lane :run_cmake_tests do
    sh 'cmake -S . -B fastlane/build/cmake -DCMAKE_BUILD_TYPE=Release'
    sh 'cmake --build fastlane/build/cmake --config Release'
    sh 'ctest --test-dir fastlane/build/cmake --output-on-failure'
  end

  private_lane :install_cocoapods do
    podfile = File.join(ROOT_DIR, 'ios', 'Podfile')
    UI.user_error!("Missing #{podfile}") unless File.exist?(podfile)
    Dir.chdir(File.join(ROOT_DIR, 'ios')) { sh 'bundle exec pod install --repo-update' }
  end

  private_lane :compile_swift_sources do
    ws = File.join(ROOT_DIR, 'ios', 'JunoNative.xcworkspace')
    pr = File.join(ROOT_DIR, 'ios', 'JunoNative.xcodeproj')
    pretty = system('which xcpretty >/dev/null') ? ' | xcpretty --no-color' : ''
    cmd = if File.exist?(ws)
            %Q[xcodebuild -workspace "#{ws}" -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' CODE_SIGNING_ALLOWED=NO build]
          else
            %Q[xcodebuild -project "#{pr}" -scheme JunoNative -configuration Release -sdk iphoneos -destination 'generic/platform=iOS' CODE_SIGNING_ALLOWED=NO build]
          end
    sh "set -o pipefail && #{cmd}#{pretty}"
  end

  private_lane :create_tmp_keychain do
    create_keychain(
      name: "fastlane_tmp_#{SecureRandom.hex(4)}",
      password: 'fastlane',
      unlock: true,
      timeout: 3600,
      lock_when_sleeps: false,
      default_keychain: false
    )
  end

  private_lane :import_dist_certificate do |keychain|
    Tempfile.create(%w[dist .p12]) do |tmp|
      tmp.binmode
      tmp.write(Base64.decode64(ENV['IOS_DIST_CERT_BASE64']))
      tmp.flush
      sh("openssl pkcs12 -in '#{tmp.path}' -nokeys -passin pass:#{ENV['IOS_DIST_CERT_PASSWORD']} -info >/dev/null 2>&1")
      import_certificate(
        keychain_name: keychain,
        certificate_path: tmp.path,
        certificate_password: ENV['IOS_DIST_CERT_PASSWORD']
      )
    end
  end

  # ---------- Verification ----------
  desc 'Sanity-check ASC API key, p12, provisioning profile'
  lane :verify_appstore_connect do
    UI.header 'üîç Verifying App Store Connect credentials & signing chain'

    %w[APPLE_ID APP_IDENTIFIER APPLE_TEAM_ID APP_STORE_CONNECT_API_KEY_ID APP_STORE_CONNECT_API_ISSUER_ID IOS_DIST_CERT_BASE64 IOS_DIST_CERT_PASSWORD].each do |v|
      UI.user_error!("Missing ENV #{v}") if ENV[v].to_s.empty?
    end

    api_key  = app_store_api_key_hash
    require 'spaceship'
    Spaceship::ConnectAPI.token = Spaceship::ConnectAPI::Token.create(**api_key)

    apps = Spaceship::ConnectAPI::App.all
    UI.success "‚úÖ Authenticated ‚Äî #{apps.size} apps in this account"
    if (bundle = ENV['APP_IDENTIFIER']).to_s != ''
      UI.success "‚úÖ Found app #{bundle}" if apps.any? { |a| a.bundle_id == bundle }
    end

    UI.header 'üîê Checking distribution certificate'
    kc = create_tmp_keychain
    import_dist_certificate(kc)
    UI.success '‚úÖ p12 imported OK'

    UI.header 'üßæ Fetching provisioning profile via sigh'
    profile_path = sigh(
      app_identifier: ENV['APP_IDENTIFIER'],
      api_key:        api_key,
      adhoc:          false,
      readonly:       false,
      skip_install:   true
    )
    ENV['SIGH_PROFILE_PATH'] = profile_path
    UI.success "‚úÖ Profile OK: #{File.basename(profile_path)}"
  ensure
    delete_keychain(name: kc) if kc && lane_context[SharedValues::BUILD_SUCCEEDED].nil?
  end

  # ---------- CI / Release ----------
  desc 'CI lane: build IPA & upload to TestFlight'
  lane :ios_ci do
    # --- 1. Verify all signing pieces, reuse what we just confirmed
    verify_appstore_connect

    # --- 2. Re-import cert into a live keychain for the actual build
    build_keychain = create_tmp_keychain
    import_dist_certificate(build_keychain)
    ENV['FASTLANE_KEYCHAIN_PATH'] = File.expand_path("~/Library/Keychains/#{build_keychain}.keychain-db")

    # --- 3. Fetch or create latest App Store profile, set env for build_app
    api_key_hash = app_store_api_key_hash
    profile_path = sigh(
      app_identifier: ENV['APP_IDENTIFIER'],
      api_key:        api_key_hash,
      adhoc:          false,
      readonly:       false,
      skip_install:   true
    )
    ENV['IOS_PROVISIONING_PROFILE_NAME'] = File.basename(profile_path, '.mobileprovision')

    # --- 4. Project prep & compile
    run_cmake_tests
    install_cocoapods
    compile_swift_sources
    build_app(ios_build_options)

    # --- 5. Upload to TestFlight
    upload_to_testflight(
      api_key: api_key_hash,
      app_identifier: ENV['APP_IDENTIFIER'],
      team_id: ENV['APPLE_TEAM_ID'],
      skip_waiting_for_build_processing: false,
      distribute_external: false
    )

    UI.success 'üçæ  Build uploaded to TestFlight!'
  ensure
    delete_keychain(name: build_keychain) if build_keychain
  end
end
