require "fileutils"
require "base64"

# --- Paths & build configuration ---
ROOT_DIR = File.expand_path("..", __dir__)
IOS_OUTPUT_DIR = ENV.fetch("IOS_ARTIFACT_DIR", File.join(ROOT_DIR, "fastlane/build/ios"))
ANDROID_OUTPUT_DIR = ENV.fetch("ANDROID_ARTIFACT_DIR", File.join(ROOT_DIR, "android/app/build/outputs/fastlane"))
ANDROID_BUNDLE_ROOT = ENV.fetch("ANDROID_BUNDLE_OUTPUT_DIR", File.join(ROOT_DIR, "android/app/build/outputs/bundle"))
CMAKE_BUILD_DIR = ENV.fetch("CMAKE_BUILD_DIR", File.join(ROOT_DIR, "fastlane/build/cmake"))
CMAKE_CONFIGURATION = ENV.fetch("CMAKE_CONFIGURATION", "Release")
IOS_BUILD_CONFIGURATION = ENV.fetch("IOS_BUILD_CONFIGURATION", "Release")
IOS_BUILD_DESTINATION = ENV.fetch("IOS_BUILD_DESTINATION", "generic/platform=iOS")
IOS_SDK = ENV.fetch("IOS_SDK", "iphoneos")

# --- Helpers ---
def resolve_ios_project_paths
  candidates = [
    { workspace: "ios/JunoNative.xcworkspace", project: "ios/JunoNative.xcodeproj" },
    { workspace: "JunoNative.xcworkspace", project: "JunoNative.xcodeproj" },
  ]

  candidates.each do |paths|
    workspace_path = File.join(ROOT_DIR, paths[:workspace])
    project_path = File.join(ROOT_DIR, paths[:project])

    if File.exist?(workspace_path)
      return { type: :workspace, path: workspace_path }
    elsif File.exist?(project_path)
      return { type: :project, path: project_path }
    end
  end

  UI.user_error!(
    "Neither ios/JunoNative.xcworkspace nor ios/JunoNative.xcodeproj nor root " \
    "JunoNative.xcworkspace/xcodeproj exists. Check your repo structure and CocoaPods installation."
  )
end

def resolve_android_bundle(build_type)
  if ANDROID_BUNDLE_ROOT.nil? || ANDROID_BUNDLE_ROOT.strip.empty?
    UI.user_error!("ANDROID_BUNDLE_OUTPUT_DIR is not set")
  end

  normalized_build_type = build_type.to_s
  normalized_build_type[0] = normalized_build_type[0].downcase if normalized_build_type.length.positive?

  candidate_directories = [
    normalized_build_type,
    build_type.to_s,
    build_type.to_s.downcase
  ].uniq

  kebab_build_type = build_type.to_s.gsub(/([a-z0-9])([A-Z])/, '\1-\2').downcase
  candidate_file_names = [
    "app-#{normalized_build_type}.aab",
    "app-#{build_type}.aab",
    "app-#{build_type.to_s.downcase}.aab",
    "app-#{kebab_build_type}.aab",
    "*.aab"
  ].uniq

  searched_dirs = []
  bundles = candidate_directories.flat_map do |dir|
    search_dir = File.join(ANDROID_BUNDLE_ROOT, dir)
    next [] unless Dir.exist?(search_dir)

    searched_dirs << search_dir

    candidate_file_names.flat_map do |file_pattern|
      Dir.glob(File.join(search_dir, file_pattern)).select { |path| File.file?(path) }
    end
  end

  UI.user_error!(
    "No Android App Bundle found. Checked directories: #{candidate_directories.map { |dir| File.join(ANDROID_BUNDLE_ROOT, dir) }.join(', ')}"
  ) if searched_dirs.empty?

  UI.user_error!(
    "No Android App Bundle found in searched directories: #{searched_dirs.join(', ')}"
  ) if bundles.empty?

  bundles.max_by { |path| File.mtime(path) }
end

def compile_cpp_engine
  FileUtils.mkdir_p(CMAKE_BUILD_DIR)

  sh("cmake -S #{ROOT_DIR} -B #{CMAKE_BUILD_DIR} -DCMAKE_BUILD_TYPE=#{CMAKE_CONFIGURATION}")
  sh("cmake --build #{CMAKE_BUILD_DIR} --config #{CMAKE_CONFIGURATION}")
end

def compile_swift_sources
  ios_paths = resolve_ios_project_paths

  xcode_target_flag =
    if ios_paths[:type] == :workspace
      "-workspace #{ios_paths[:path]}"
    else
      "-project #{ios_paths[:path]}"
    end

  sh <<~CMD
    set -o pipefail && xcodebuild \
      #{xcode_target_flag} \
      -scheme JunoNative \
      -configuration #{IOS_BUILD_CONFIGURATION} \
      -sdk #{IOS_SDK} \
      -destination '#{IOS_BUILD_DESTINATION}' \
      CODE_SIGNING_ALLOWED=NO \
      build
  CMD
end

# Build a proper Hash for Fastlane's api_key parameter using your base64 p8.
# Uses environment variables:
#  - APP_STORE_CONNECT_API_KEY_ID
#  - APP_STORE_CONNECT_API_ISSUER_ID
#  - APP_STORE_CONNECT_API_KEY_BASE64
def app_store_api_key_hash
  decoded_key = Base64.decode64(ENV.fetch("APP_STORE_CONNECT_API_KEY_BASE64"))

  {
    key_id:    ENV.fetch("APP_STORE_CONNECT_API_KEY_ID"),
    issuer_id: ENV.fetch("APP_STORE_CONNECT_API_ISSUER_ID"),
    key:       decoded_key,
    in_house:  false
  }
end

# Choose workspace or project dynamically for build_app, and inject api_key if provided.
def ios_build_options(api_key: nil)
  ios_paths = resolve_ios_project_paths
  base = {
    scheme:          "JunoNative",
    configuration:   IOS_BUILD_CONFIGURATION,
    export_method:   "app-store",
    destination:     IOS_BUILD_DESTINATION,
    output_directory: IOS_OUTPUT_DIR,
    output_name:     ENV.fetch("IOS_OUTPUT_NAME", "JunoNative.ipa")
  }

  if ios_paths[:type] == :workspace
    base[:workspace] = ios_paths[:path]
  else
    base[:project] = ios_paths[:path]
  end

  base[:api_key] = api_key if api_key
  base
end

default_platform(:ios)

platform :ios do
  desc "Manual iOS release: build and upload to TestFlight using Apple ID session"
  lane :release do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    script_path = File.join(ROOT_DIR, "scripts/compile-turbo-modules.sh")
    sh("bash #{script_path}") if File.exist?(script_path)

    compile_swift_sources

    build_app(ios_build_options)

    upload_to_testflight(
      skip_waiting_for_build_processing: true
    )
  end

  desc "Beta: build and upload using App Store Connect API key (base64)"
  lane :beta do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    script_path = File.join(ROOT_DIR, "scripts/compile-turbo-modules.sh")
    sh("bash #{script_path}") if File.exist?(script_path)

    compile_swift_sources

    api_key = app_store_api_key_hash

    build_app(ios_build_options(api_key: api_key))

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end

  desc "CI lane: used by GitHub Actions to build + upload to TestFlight (API key, base64)"
  lane :ios_ci do
    FileUtils.mkdir_p(IOS_OUTPUT_DIR)

    compile_cpp_engine
    script_path = File.join(ROOT_DIR, "scripts/compile-turbo-modules.sh")
    sh("bash #{script_path}") if File.exist?(script_path)

    compile_swift_sources

    api_key = app_store_api_key_hash

    build_app(ios_build_options(api_key: api_key))

    upload_to_testflight(
      api_key: api_key,
      skip_waiting_for_build_processing: true
    )
  end
end

# --- Android lanes (kept for completeness) ---
platform :android do
  desc "Build and upload to Play Console internal track"
  lane :release do |options|
    FileUtils.mkdir_p(ANDROID_OUTPUT_DIR)

    compile_cpp_engine
    script_path = File.join(ROOT_DIR, "scripts/compile-turbo-modules.sh")
    sh("bash #{script_path}") if File.exist?(script_path)

    build_type = options[:build_type] || ENV.fetch("ANDROID_BUILD_TYPE", "Release")

    gradlew_path = File.join(ROOT_DIR, "android/gradlew")
    UI.user_error!("Gradle wrapper not found at #{gradlew_path}") unless File.exist?(gradlew_path)

    gradle(
      task: "bundle",
      build_type: build_type,
      project_dir: "android"
    )

    release_bundle = resolve_android_bundle(build_type)

    archived_bundle = File.join(
      ANDROID_OUTPUT_DIR,
      ENV.fetch("ANDROID_BUNDLE_NAME", File.basename(release_bundle))
    )
    FileUtils.cp(release_bundle, archived_bundle)

    upload_to_play_store(track: "internal", aab: archived_bundle)
  end
end
