require "plist"

default_platform(:ios)

# Helper to construct App Store Connect API key hash from environment variables
# Helper to construct App Store Connect API key hash from environment variables
def app_store_api_key_hash
  api_key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
  issuer_id  = ENV["APP_STORE_CONNECT_API_ISSUER_ID"] || ENV["APP_STORE_CONNECT_API_KEY_ISSUER_ID"]
  key_base64 = ENV["APP_STORE_CONNECT_API_KEY_BASE64"]
  raw_key    = ENV["APP_STORE_CONNECT_API_KEY"]

  # Validate required pieces
  if api_key_id.to_s.strip.empty? || issuer_id.to_s.strip.empty?
    UI.user_error!("APP_STORE_CONNECT_API_KEY_ID and APP_STORE_CONNECT_API_ISSUER_ID must be set")
  end

  if key_base64.to_s.strip.empty? && raw_key.to_s.strip.empty?
    UI.user_error!("Either APP_STORE_CONNECT_API_KEY_BASE64 or APP_STORE_CONNECT_API_KEY must be set")
  end

  require "base64"
  key_content =
    if !key_base64.to_s.strip.empty?
      Base64.decode64(key_base64)
    else
      raw_key
    end

  {
    key_id:    api_key_id,
    issuer_id: issuer_id,
    key:       key_content,
    in_house:  false
  }
end

# iOS build options shared between local + CI
def ios_build_options
  workspace_path = File.expand_path("../ios/JunoNative.xcworkspace", __dir__)
  project_path   = File.expand_path("../ios/JunoNative.xcodeproj", __dir__)

  has_workspace = File.exist?(workspace_path)
  has_project   = File.exist?(project_path)

  if has_workspace
    UI.message("Using workspace at: #{workspace_path}")
  elsif has_project
    UI.message("Using project at: #{project_path}")
  else
    UI.user_error!("Neither #{workspace_path} nor #{project_path} exists. Check your repo structure and CocoaPods installation.")
  end

  export_options_plist = File.expand_path("../ios/exportOptions.plist", __dir__)
  unless File.exist?(export_options_plist)
    UI.user_error!("exportOptions.plist not found at #{export_options_plist}")
  end

  plist_export_options = Plist.parse_xml(export_options_plist) || {}
  unless ENV["APPLE_TEAM_ID"].to_s.strip.empty?
    plist_export_options["teamID"] = ENV["APPLE_TEAM_ID"]
  end

  profile_name   = ENV["IOS_PROVISIONING_PROFILE_NAME"]
  app_identifier = ENV["APP_IDENTIFIER"]

  if profile_name.to_s.strip.empty?
    plist_export_options["signingStyle"] = "automatic"
  elsif app_identifier.to_s.strip.empty?
    UI.user_error!("IOS_PROVISIONING_PROFILE_NAME was provided but APP_IDENTIFIER is missing")
  else
    plist_export_options["provisioningProfiles"] ||= {}
    plist_export_options["provisioningProfiles"][app_identifier] = profile_name
    plist_export_options["signingStyle"] = "manual"
  end

  {
    workspace:        has_workspace ? workspace_path : nil,
    project:          has_workspace ? nil : project_path,
    scheme:           "JunoNative",
    configuration:    "Release",
    clean:            true,

    output_directory: File.expand_path("../fastlane/build/ios", __dir__),
    output_name:      ENV["IOS_OUTPUT_NAME"] || "JunoNative.ipa",

    silent:           false,
    skip_package_ipa: false,
    skip_package_pkg: true,
    include_symbols:  true,
    include_bitcode:  false,

    # ðŸ”‘ Use explicit exportOptions plist instead of export_method
    export_options:   plist_export_options,

    skip_profile_detection: false,
    result_bundle:          true,
    buildlog_path:         File.expand_path("../fastlane/logs", __dir__),

    # Help Xcode pick the right team in CI
    export_xcargs: "DEVELOPMENT_TEAM=#{ENV['APPLE_TEAM_ID']}"
  }.compact
end

platform :ios do
  desc "Run unit tests for the Juno DSP core via CMake/CTest"
  lane :dsp_tests do
    sh("cmake -S . -B fastlane/build/cmake -DCMAKE_BUILD_TYPE=Debug")
    sh("cmake --build fastlane/build/cmake --config Debug --target juno_tests")
    sh("ctest --test-dir fastlane/build/cmake --output-on-failure")
  end

  desc "Compile the C++ DSP engine and run basic tests"
  lane :compile_dsp_engine do
    # Fastfile lives in fastlane/, so the project root is one level up
    project_root = File.expand_path("..", __dir__)
    build_dir    = File.join(project_root, "fastlane", "build", "cmake")

    sh("cmake -S #{project_root} -B #{build_dir} -DCMAKE_BUILD_TYPE=Release")
    sh("cmake --build #{build_dir} --config Release")
  end

  desc "Compile React Native TurboModules (JSI/Native codegen)"
  lane :compile_turbo_modules do
    # Fastfile is in fastlane/, project root is one level up
    project_root = File.expand_path("..", __dir__)
    script_path  = File.join(project_root, "scripts", "compile-turbo-modules.sh")

    unless File.exist?(script_path)
      UI.user_error!("TurboModules script not found at #{script_path}")
    end

    UI.message("Running TurboModule codegen using #{script_path}")
    sh("bash #{script_path}")
  end

  # --- CocoaPods installation lane, correct path + working dir ---
  private_lane :install_cocoapods do
    ios_dir = File.expand_path("../ios", __dir__)
    podfile = File.join(ios_dir, "Podfile")

    unless File.exist?(podfile)
      UI.user_error!("Podfile not found at #{podfile}. Cannot run pod install.")
    end

    UI.message("Running CocoaPods install in #{ios_dir}")
    Dir.chdir(ios_dir) do
      # Using bundler because CI invokes `bundle exec fastlane`
      sh("bundle exec pod install --repo-update")
    end
  end

  private_lane :prepare_build_assets do
    compile_dsp_engine
    compile_turbo_modules
  end

  private_lane :compile_swift_sources do
    workspace_path = File.expand_path("../ios/JunoNative.xcworkspace", __dir__)
    project_path   = File.expand_path("../ios/JunoNative.xcodeproj", __dir__)

    xcpretty_available = system("which xcpretty >/dev/null 2>&1")
    formatter_suffix = xcpretty_available ? " | xcpretty --no-color" : ""

    if File.exist?(workspace_path)
      UI.message("Compiling Swift sources using workspace: #{workspace_path}")
      sh(%Q[
        set -o pipefail && xcodebuild \
          -workspace "#{workspace_path}" \
          -scheme JunoNative \
          -configuration Release \
          -sdk iphoneos \
          -destination 'generic/platform=iOS' \
          CODE_SIGNING_ALLOWED=NO \
          build#{formatter_suffix}
      ])
    elsif File.exist?(project_path)
      UI.message("Workspace not found; compiling Swift sources using project: #{project_path}")
      sh(%Q[
        set -o pipefail && xcodebuild \
          -project "#{project_path}" \
          -scheme JunoNative \
          -configuration Release \
          -sdk iphoneos \
          -destination 'generic/platform=iOS' \
          CODE_SIGNING_ALLOWED=NO \
          build#{formatter_suffix}
      ])
    else
      UI.user_error!("Neither #{workspace_path} nor #{project_path} exists. Check your repo structure and CocoaPods installation.")
    end
  end

  desc "Local build for iOS (no upload)"
  lane :build do
    prepare_build_assets
    install_cocoapods
    compile_swift_sources

    build_app(ios_build_options)
  end

  desc "CI lane: build iOS app and upload to TestFlight using App Store Connect API key"
  lane :ios_ci do
    UI.message("Starting iOS CI laneâ€¦")

    prepare_build_assets
    install_cocoapods
    compile_swift_sources

    require "base64"
    require "tempfile"
    api_key = app_store_api_key_hash
    ENV["SPACESHIP_CONNECT_API_IN_HOUSE"] ||= "false"
    required_env_with_examples = {
      "IOS_DIST_CERT_BASE64" => "export IOS_DIST_CERT_BASE64='<base64-encoded p12>'",
      "IOS_DIST_CERT_PASSWORD" => "export IOS_DIST_CERT_PASSWORD='your_p12_password'",
      "APPLE_ID" => "export APPLE_ID='developer@example.com'",
      "APP_IDENTIFIER" => "export APP_IDENTIFIER='com.example.app'",
      "APPLE_TEAM_ID" => "export APPLE_TEAM_ID='YOURTEAMID'",
      "APP_STORE_CONNECT_API_KEY_ID" => "export APP_STORE_CONNECT_API_KEY_ID='ABC123'",
      "APP_STORE_CONNECT_API_ISSUER_ID" => "export APP_STORE_CONNECT_API_ISSUER_ID='YOUR-ISSUER-ID'"
    }

    required_env_with_examples.each do |var, example|
      if ENV[var].to_s.strip.empty?
        UI.user_error!("Environment variable #{var} must be set before building. Set it via CI secrets or locally using #{example}.")
      end
    end

    dist_cert_base64 = ENV["IOS_DIST_CERT_BASE64"]

    UI.message("Requesting App Store provisioning profile via sigh")
    profile_path = sigh(
      app_identifier: ENV["APP_IDENTIFIER"],
      api_key: api_key,
      adhoc: false,
      readonly: true
    )
    profile_name = Actions.lane_context[SharedValues::SIGH_PROFILE_NAME] || File.basename(profile_path.to_s, ".mobileprovision")

    UI.message("Importing distribution certificate from IOS_DIST_CERT_BASE64")
    dist_p12 = Base64.decode64(dist_cert_base64)
    Tempfile.create(["dist", ".p12"]) do |temp_p12|
      temp_p12.binmode
      temp_p12.write(dist_p12)
      temp_p12.flush

      import_certificate(
        certificate_path:     temp_p12.path,
        certificate_password: ENV["IOS_DIST_CERT_PASSWORD"]
      )
    end

    ENV["IOS_PROVISIONING_PROFILE_NAME"] = profile_name

    build_app(ios_build_options)

    apple_app_id = ENV["APP_APPLE_ID"].to_s.strip

    upload_to_testflight(
      api_key:                           api_key,
      app_identifier:                    ENV["APP_IDENTIFIER"],
      team_id:                           ENV["APPLE_TEAM_ID"],
      apple_id:                          apple_app_id.empty? ? nil : apple_app_id,
      skip_waiting_for_build_processing: false,
      distribute_external:               false,
      beta_app_review_info: {
        contact_email:         ENV["APPLE_ID"],
        contact_first_name:    "Alexis",
        contact_last_name:     "Boulet",
        contact_phone:         "",
        demo_account_name:     "",
        demo_account_password: "",
        notes:                 "JunoNative CI build"
      }
    )
  end
end
