name: iOS Manual Deploy (App Store Connect / TestFlight)

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: "Release notes for TestFlight (optional)"
        required: false
        default: ""

jobs:
  ios_manual_deploy:
    runs-on: macos-15
    timeout-minutes: 60

    env:
      # --- Required secrets (GitHub repo secrets) ---
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APP_IDENTIFIER: ${{ secrets.APP_IDENTIFIER }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      # App Store Connect API key (.p8) as BASE64 (single-line)
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
      APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}

      # Distribution cert (.p12) as BASE64 (single-line) and password
      IOS_DIST_CERT_BASE64: ${{ secrets.IOS_DIST_CERT_BASE64 }}
      IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}

      # Provisioning profile (.mobileprovision) as BASE64 (single-line)
      IOS_PROFILE_BASE64: ${{ secrets.IOS_PROFILE_BASE64 }}

      # Keychain password (recommended set)
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}

      # --- Build config ---
      XCODE_WORKSPACE: ios/JunoNative.xcworkspace
      XCODE_SCHEME: JunoNative
      CONFIGURATION: Release

      NODE_VERSION: "22"

    steps:
      - name: üßæ Checkout code
        uses: actions/checkout@v4

      - name: üß∞ Select Xcode 16.x
        shell: bash
        run: |
          set -euo pipefail
          XCODE_APP="$(ls -d /Applications/Xcode_16*.app | head -n 1 || true)"
          if [ -z "$XCODE_APP" ]; then
            echo "‚ùå No /Applications/Xcode_16*.app found on runner."
            ls -la /Applications | sed -n '1,200p'
            exit 1
          fi
          echo "Using: $XCODE_APP"
          sudo xcode-select -s "$XCODE_APP"
          xcodebuild -version

      - name: Compute build paths
        shell: bash
        run: |
          set -euo pipefail
          echo "ARCHIVE_PATH=$RUNNER_TEMP/JunoNative.xcarchive" >> "$GITHUB_ENV"
          echo "ARCHIVE_INFO_PLIST=$RUNNER_TEMP/JunoNative.xcarchive/Info.plist" >> "$GITHUB_ENV"
          echo "EXPORT_DIR=$RUNNER_TEMP/build" >> "$GITHUB_ENV"
          echo "EXPORT_OPTIONS_PLIST=$RUNNER_TEMP/ExportOptions.plist" >> "$GITHUB_ENV"
          echo "ASC_DIR=$RUNNER_TEMP/asc" >> "$GITHUB_ENV"
          echo "ASC_API_KEY_JSON=$RUNNER_TEMP/api_key.json" >> "$GITHUB_ENV"
          echo "PROFILE_PLIST=$RUNNER_TEMP/profile.plist" >> "$GITHUB_ENV"
          echo "XCODEBUILD_ARCHIVE_LOG=$RUNNER_TEMP/xcodebuild-archive.log" >> "$GITHUB_ENV"
          echo "XCODEBUILD_EXPORT_LOG=$RUNNER_TEMP/xcodebuild-export.log" >> "$GITHUB_ENV"

      - name: üü© Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: üì¶ Install JS deps (lockfile-aware)
        shell: bash
        run: |
          set -euo pipefail
          corepack enable || true

          if [ -f "yarn.lock" ]; then
            echo "Using yarn"
            yarn --version
            yarn install --frozen-lockfile
          elif [ -f "package-lock.json" ]; then
            echo "Using npm"
            node --version
            npm --version
            npm ci
          elif [ -f "pnpm-lock.yaml" ]; then
            echo "Using pnpm"
            corepack prepare pnpm@latest --activate
            pnpm --version
            pnpm install --frozen-lockfile
          else
            echo "‚ö†Ô∏è No lockfile found; defaulting to yarn install"
            yarn install
          fi

      - name: üíé Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: üíé Ensure fastlane + cocoapods + xcpretty
        shell: bash
        run: |
          set -euo pipefail
          gem install fastlane -N
          gem install cocoapods -N
          gem install xcpretty -N

      - name: üß∞ Install CocoaPods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install --repo-update

      - name: üîê Create temporary keychain
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="$RUNNER_TEMP/ios-build.keychain-db"
          KC_PW="${KEYCHAIN_PASSWORD:-temp-pass}"

          security create-keychain -p "$KC_PW" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KC_PW" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" "$HOME/Library/Keychains/login.keychain-db"
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KC_PW" >> "$GITHUB_ENV"

      - name: ü™™ Import signing certificate (p12) + enable codesign access
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${IOS_DIST_CERT_BASE64:-}" ]; then
            echo "‚ùå IOS_DIST_CERT_BASE64 is empty."
            exit 1
          fi
          if [ -z "${IOS_DIST_CERT_PASSWORD:-}" ]; then
            echo "‚ùå IOS_DIST_CERT_PASSWORD is empty."
            exit 1
          fi

          CERT_P12="$RUNNER_TEMP/ios_dist.p12"
          python3 - <<'PY'
          import os, re, base64, sys
          s = re.sub(r"\s+", "", os.environ["IOS_DIST_CERT_BASE64"])
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in IOS_DIST_CERT_BASE64:", e)
            sys.exit(2)
          with open(os.environ["CERT_P12"], "wb") as f:
            f.write(data)
          print("p12 bytes:", len(data))
          PY

          security import "$CERT_P12" \
            -k "$KEYCHAIN_PATH" \
            -P "$IOS_DIST_CERT_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/xcodebuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -q "Apple Distribution" || {
            echo "‚ùå Apple Distribution identity not found after import."
            exit 1
          }
        env:
          CERT_P12: ${{ runner.temp }}/ios_dist.p12

      - name: üìÑ Decode provisioning profile (IOS_PROFILE_BASE64)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${IOS_PROFILE_BASE64:-}" ]; then
            echo "‚ùå IOS_PROFILE_BASE64 is empty."
            exit 1
          fi

          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"

          PP_FILE="$RUNNER_TEMP/profile.mobileprovision"
          python3 - <<'PY'
          import os, re, base64, sys
          s = re.sub(r"\s+", "", os.environ["IOS_PROFILE_BASE64"])
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in IOS_PROFILE_BASE64:", e)
            sys.exit(2)
          out = os.environ["PP_FILE"]
          with open(out, "wb") as f:
            f.write(data)
          print("profile bytes:", len(data))
          if len(data) < 500:
            print("Decoded provisioning profile is suspiciously small (<500 bytes).")
            sys.exit(3)
          PY

          /usr/bin/security cms -D -i "$PP_FILE" > "$PROFILE_PLIST"

          UUID=$(/usr/libexec/PlistBuddy -c 'Print:UUID' "$PROFILE_PLIST")
          NAME=$(/usr/libexec/PlistBuddy -c 'Print:Name' "$PROFILE_PLIST")

          cp "$PP_FILE" "$PP_DIR/$UUID.mobileprovision"

          echo "PROFILE_UUID=$UUID" >> "$GITHUB_ENV"
          echo "PROFILE_NAME=$NAME" >> "$GITHUB_ENV"
          echo "Imported provisioning profile: $NAME ($UUID)"
        env:
          PP_FILE: ${{ runner.temp }}/profile.mobileprovision

      - name: üîë Decode App Store Connect API key (p8)
        shell: bash
        run: |
          set -euo pipefail

          if [ -z "${APP_STORE_CONNECT_API_KEY_BASE64:-}" ]; then
            echo "‚ùå APP_STORE_CONNECT_API_KEY_BASE64 is empty."
            exit 1
          fi
          if [ -z "${APP_STORE_CONNECT_API_KEY_ID:-}" ] || [ -z "${APP_STORE_CONNECT_API_KEY_ISSUER_ID:-}" ]; then
            echo "‚ùå API key id/issuer missing."
            exit 1
          fi

          mkdir -p "$ASC_DIR"
          ASC_P8_PATH="$ASC_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"

          python3 - <<'PY'
          import os, re, base64, sys
          s = re.sub(r"\s+", "", os.environ["APP_STORE_CONNECT_API_KEY_BASE64"])
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in APP_STORE_CONNECT_API_KEY_BASE64:", e)
            sys.exit(2)
          out = os.environ["ASC_P8_PATH"]
          with open(out, "wb") as f:
            f.write(data)
          print("p8 bytes:", len(data))
          if len(data) < 100:
            print("Decoded .p8 key is suspiciously small (<100 bytes).")
            sys.exit(3)
          PY

          chmod 600 "$ASC_P8_PATH"
          echo "ASC_API_KEY_PATH=$ASC_P8_PATH" >> "$GITHUB_ENV"
        env:
          ASC_P8_PATH: ${{ runner.temp }}/asc/AuthKey_${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}.p8

      - name: üß™ Assert scheme builds an Application (not a framework)
        shell: bash
        run: |
          set -euo pipefail
          PT=$(xcodebuild -showBuildSettings \
            -workspace "$XCODE_WORKSPACE" \
            -scheme "$XCODE_SCHEME" \
            -configuration "$CONFIGURATION" | awk -F' = ' '/^ *PRODUCT_TYPE/ {print $2; exit}')
          echo "PRODUCT_TYPE=$PT"
          if [ "$PT" != "com.apple.product-type.application" ]; then
            echo "‚ùå Scheme '$XCODE_SCHEME' is not an application. Fix scheme/target (must archive the app)."
            exit 2
          fi

      - name: üèóÔ∏è Build archive (xcodebuild archive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$ARCHIVE_PATH"

          set +o pipefail
          xcodebuild \
            -workspace "$XCODE_WORKSPACE" \
            -scheme "$XCODE_SCHEME" \
            -configuration "$CONFIGURATION" \
            -sdk iphoneos \
            -archivePath "$ARCHIVE_PATH" \
            -destination "generic/platform=iOS" \
            DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
            PRODUCT_BUNDLE_IDENTIFIER="$APP_IDENTIFIER" \
            archive 2>&1 | tee "$XCODEBUILD_ARCHIVE_LOG" | xcpretty
          XC=${PIPESTATUS[0]}
          set -o pipefail
          exit $XC

      - name: üîé Verify archive structure (must contain Products/Applications/*.app)
        shell: bash
        run: |
          set -euo pipefail
          echo "Archive tree (top):"
          find "$ARCHIVE_PATH" -maxdepth 3 -print

          if [ ! -d "$ARCHIVE_PATH/Products/Applications" ]; then
            echo "‚ùå Missing Products/Applications ‚Äî this is a Generic Archive"
            exit 2
          fi

          echo "‚úÖ Apps:"
          ls -la "$ARCHIVE_PATH/Products/Applications"
          test -n "$(find "$ARCHIVE_PATH/Products/Applications" -maxdepth 1 -name "*.app" -print -quit)"

      - name: üßæ Create ExportOptions.plist (App Store / TestFlight)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, plistlib
          export_options = {
            "method": "app-store",
            "destination": "export",
            "signingStyle": "manual",
            "teamID": os.environ["APPLE_TEAM_ID"],
            "provisioningProfiles": {
              os.environ["APP_IDENTIFIER"]: os.environ["PROFILE_NAME"]
            },
            "stripSwiftSymbols": True,
            "compileBitcode": False,
            "uploadSymbols": True
          }
          with open(os.environ["EXPORT_OPTIONS_PLIST"], "wb") as f:
            plistlib.dump(export_options, f)
          PY
          /usr/bin/plutil -lint "$EXPORT_OPTIONS_PLIST"

      - name: üì§ Export IPA (xcodebuild -exportArchive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$EXPORT_DIR"
          mkdir -p "$EXPORT_DIR"

          set +o pipefail
          xcodebuild \
            -exportArchive \
            -archivePath "$ARCHIVE_PATH" \
            -exportPath "$EXPORT_DIR" \
            -exportOptionsPlist "$EXPORT_OPTIONS_PLIST" 2>&1 | tee "$XCODEBUILD_EXPORT_LOG" | xcpretty
          XC=${PIPESTATUS[0]}
          set -o pipefail

          if [ "$XC" -eq 0 ]; then
            ls -la "$EXPORT_DIR"
            test -n "$(find "$EXPORT_DIR" -maxdepth 1 -name "*.ipa" -print -quit)"
          fi

          exit $XC

      - name: üöÄ Upload to TestFlight (fastlane pilot)
        shell: bash
        env:
          RELEASE_NOTES: ${{ inputs.release_notes }}
        run: |
          set -euo pipefail

          IPA_PATH="$(find "$EXPORT_DIR" -maxdepth 1 -name "*.ipa" | head -n 1)"
          if [ -z "$IPA_PATH" ]; then
            echo "‚ùå IPA not found in $EXPORT_DIR"
            exit 1
          fi

          python3 - <<'PY'
          import os, json
          p8_path = os.environ["ASC_API_KEY_PATH"]
          with open(p8_path, "r", encoding="utf-8") as f:
            key_text = f.read()
          payload = {
            "key_id": os.environ["APP_STORE_CONNECT_API_KEY_ID"],
            "issuer_id": os.environ["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
            "key": key_text
          }
          with open(os.environ["ASC_API_KEY_JSON"], "w", encoding="utf-8") as f:
            json.dump(payload, f)
          PY

          fastlane pilot upload \
            --api_key_path "$ASC_API_KEY_JSON" \
            --ipa "$IPA_PATH" \
            --skip_waiting_for_build_processing true \
            --changelog "${RELEASE_NOTES:-}"

      - name: üìé Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-artifacts
          path: |
            ${{ env.EXPORT_OPTIONS_PLIST }}
            ${{ env.PROFILE_PLIST }}
            ${{ env.ARCHIVE_INFO_PLIST }}
            ${{ env.ARCHIVE_PATH }}
            ${{ env.EXPORT_DIR }}
            ${{ env.XCODEBUILD_ARCHIVE_LOG }}
            ${{ env.XCODEBUILD_EXPORT_LOG }}

      - name: üßπ Cleanup keychain
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${KEYCHAIN_PATH:-}" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
