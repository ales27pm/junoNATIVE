name: iOS Manual Deploy (App Store Connect / TestFlight)

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: "Release notes for TestFlight (optional)"
        required: false
        default: ""

jobs:
  ios_manual_deploy:
    runs-on: macos-15
    timeout-minutes: 60

    env:
      # --- Required secrets (GitHub repo secrets) ---
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APP_IDENTIFIER: ${{ secrets.APP_IDENTIFIER }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      # App Store Connect API key (.p8) as BASE64 (single-line)
      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
      APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}

      # Distribution cert (.p12) as BASE64 (single-line) and password
      IOS_DIST_CERT_BASE64: ${{ secrets.IOS_DIST_CERT_BASE64 }}
      IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}

      # Provisioning profile (.mobileprovision) as BASE64 (single-line)
      IOS_PROFILE_BASE64: ${{ secrets.IOS_PROFILE_BASE64 }}

      # Keychain password (can be empty but better set)
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}

      # --- Build config ---
      XCODE_WORKSPACE: ios/JunoNative.xcworkspace
      XCODE_SCHEME: JunoNative
      CONFIGURATION: Release

      # Node
      NODE_VERSION: "22"

    steps:
      - name: ðŸ§¾ Checkout code
        uses: actions/checkout@v4

      - name: ðŸ§° Select Xcode 16
        shell: bash
        run: |
          set -euo pipefail
          sudo xcode-select -s /Applications/Xcode_16.app
          xcodebuild -version

      - name: Compute build paths
        shell: bash
        run: |
          set -euo pipefail
          echo "EXPORT_OPTIONS_PLIST=$RUNNER_TEMP/ExportOptions.plist" >> "$GITHUB_ENV"
          echo "ARCHIVE_PATH=$RUNNER_TEMP/JunoNative.xcarchive" >> "$GITHUB_ENV"
          echo "ARCHIVE_INFO_PLIST=$RUNNER_TEMP/JunoNative.xcarchive/Info.plist" >> "$GITHUB_ENV"
          echo "EXPORT_DIR=$RUNNER_TEMP/build" >> "$GITHUB_ENV"
          echo "ASC_DIR=$RUNNER_TEMP/asc" >> "$GITHUB_ENV"
          echo "ASC_API_KEY_JSON=$RUNNER_TEMP/api_key.json" >> "$GITHUB_ENV"
          echo "PROFILE_PLIST=$RUNNER_TEMP/profile.plist" >> "$GITHUB_ENV"
          echo "XCPRETTY_CMD=" >> "$GITHUB_ENV"
          echo "XCODEBUILD_ARCHIVE_LOG=$RUNNER_TEMP/xcodebuild-archive.log" >> "$GITHUB_ENV"
          echo "XCODEBUILD_EXPORT_LOG=$RUNNER_TEMP/xcodebuild-export.log" >> "$GITHUB_ENV"

      - name: ðŸ§  Detect JS package manager (Option B)
        id: pm
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "yarn.lock" ]; then
            echo "manager=yarn" >> "$GITHUB_OUTPUT"
          elif [ -f "package-lock.json" ]; then
            echo "manager=npm" >> "$GITHUB_OUTPUT"
          elif [ -f "pnpm-lock.yaml" ]; then
            echo "manager=pnpm" >> "$GITHUB_OUTPUT"
          else
            echo "manager=yarn" >> "$GITHUB_OUTPUT"
          fi
          echo "Detected JS package manager: ${{ steps.pm.outputs.manager }}"

      - name: ðŸŸ© Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ“¦ Install JS deps (lockfile-aware)
        shell: bash
        run: |
          set -euo pipefail
          corepack enable |

| true

          case "${{ steps.pm.outputs.manager }}" in
            yarn)
              echo "Using Yarn..."
              yarn --version
              if [ -f "yarn.lock" ]; then
                yarn install --frozen-lockfile
              else
                echo "âš ï¸ No yarn.lock found; running non-frozen install."
                yarn install
              fi
              ;;
            npm)
              echo "Using npm..."
              node --version
              npm --version
              if [ -f "package-lock.json" ]; then
                npm ci
              else
                npm install
              fi
              ;;
            pnpm)
              echo "Using pnpm..."
              pnpm --version |

| corepack prepare pnpm@latest --activate
              if [ -f "pnpm-lock.yaml" ]; then
                pnpm install --frozen-lockfile
              else
                pnpm install
              fi
              ;;
            *)
              echo "Unknown package manager selection."
              exit 1
              ;;
          esac

      - name: ðŸ’Ž Detect Ruby strategy (Bundler vs gem install)
        id: ruby
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "Gemfile" ]; then
            echo "use_bundler=true" >> "$GITHUB_OUTPUT"
          else
            echo "use_bundler=false" >> "$GITHUB_OUTPUT"
          fi

      - name: ðŸ’Ž Setup Ruby (Bundler cache)
        if: ${{ steps.ruby.outputs.use_bundler == 'true' }}
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: true

      - name: ðŸ’Ž Setup Ruby (no Gemfile)
        if: ${{ steps.ruby.outputs.use_bundler!= 'true' }}
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"

      - name: ðŸ’Ž Install fastlane/cocoapods (no Gemfile)
        if: ${{ steps.ruby.outputs.use_bundler!= 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          gem install fastlane -N
          gem install cocoapods -N

      - name: ðŸ§° Install CocoaPods (with fallback)
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          if [ "${{ steps.ruby.outputs.use_bundler }}" = "true" ]; then
            if bundle exec pod --version >/dev/null 2>&1; then
              bundle exec pod install --repo-update
            else
              echo "âš ï¸ cocoapods not present in bundle; installing globally as fallback."
              gem install cocoapods -N
              pod install --repo-update
            fi
          else
            pod install --repo-update
          fi

      - name: ðŸ§¾ Ensure xcpretty exists (hard guarantee)
        shell: bash
        run: |
          set -euo pipefail

          if [ "${{ steps.ruby.outputs.use_bundler }}" = "true" ]; then
            if bundle exec ruby -S xcpretty --version >/dev/null 2>&1; then
              echo "XCPRETTY_CMD=bundle exec xcpretty" >> "$GITHUB_ENV"
              bundle exec ruby -S xcpretty --version |

| true
              exit 0
            fi
          fi

          if! command -v xcpretty >/dev/null 2>&1; then
            gem install xcpretty -N
          fi

          xcpretty --version |

| true
          echo "XCPRETTY_CMD=xcpretty" >> "$GITHUB_ENV"

      - name: âš™ï¸ Enforce SKIP_INSTALL Settings (Critical Fix)
        # Fixes the Generic Archive error by explicitly setting installation status
        # on the main app target and dependencies, which prevents the distribution failure.
        shell: bash
        run: |
          set -euo pipefail
          
          if [ "${{ steps.ruby.outputs.use_bundler }}" = "true" ]; then
            RUBY_CMD="bundle exec"
          else
            RUBY_CMD=""
            # Need xcodeproj gem to modify project files
            gem install xcodeproj -N |

| true
          fi

          $RUBY_CMD ruby -e '
          require "xcodeproj"
          
          # Open the main application project
          project_path = "ios/JunoNative.xcodeproj"
          proj = Xcodeproj::Project.open(project_path)
          
          # Target 1: The main application executable (JunoNative)
          main_target = proj.targets.find { |t| t.name == "JunoNative" }
          
          if main_target
            # Must set SKIP_INSTALL = NO so the.app gets archived correctly.
            main_target.build_configurations.each do |config|
              puts "Setting SKIP_INSTALL=NO for JunoNative in #{config.name}."
              config.build_settings = "NO"
            end
          else
            puts "Warning: JunoNative main target not found."
          end

          # Target 2: The CocoaPods dependencies project
          pods_project_path = "ios/Pods/Pods.xcodeproj"
          if File.exist?(pods_project_path)
            pods_proj = Xcodeproj::Project.open(pods_project_path)
            
            # Must set SKIP_INSTALL = YES for all dependency targets (like libs and frameworks)
            # This ensures they are embedded but not separately installed in the archive root.
            pods_proj.targets.each do |target|
              target.build_configurations.each do |config|
                puts "Setting SKIP_INSTALL=YES for Pod dependency target #{target.name} in #{config.name}."
                config.build_settings = "YES"
              end
            end
            pods_proj.save
          end
          
          proj.save
          puts "âœ… Project files updated with correct SKIP_INSTALL settings."
          '

      - name: ðŸ” Create temporary keychain
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="$RUNNER_TEMP/ios-build.keychain-db"
          KEYCHAIN_PASSWORD="${KEYCHAIN_PASSWORD:-temp-pass}"

          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          security list-keychains -d user -s "$KEYCHAIN_PATH" "$HOME/Library/Keychains/login.keychain-db"
          security default-keychain -s "$KEYCHAIN_PATH"

          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

      - name: ðŸªª Import signing certificate (p12) + enable codesign access
        shell: bash
        run: |
          set -euo pipefail

          if; then
            echo "IOS_DIST_CERT_BASE64 is empty. Set it in GitHub Secrets."
            exit 1
          fi
          if; then
            echo "IOS_DIST_CERT_PASSWORD is empty. Set it in GitHub Secrets."
            exit 1
          fi

          CERT_P12="$RUNNER_TEMP/ios_dist.p12"
          export CERT_P12

          python3 - <<'PY'
          import os, re, base64, sys
          s = os.environ.get("IOS_DIST_CERT_BASE64", "")
          s = re.sub(r"\s+", "", s)
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in IOS_DIST_CERT_BASE64:", e)
            sys.exit(2)
          out = os.environ
          with open(out, "wb") as f:
            f.write(data)
          print("p12 bytes:", len(data))
          PY

          security import "$CERT_P12" \
            -k "$KEYCHAIN_PATH" \
            -P "$IOS_DIST_CERT_PASSWORD" \
            -T /usr/bin/codesign \
            -T /usr/bin/security \
            -T /usr/bin/xcodebuild \
            -T /usr/bin/productbuild

          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          echo "Available signing identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          if! security find-identity -v -p codesigning "$KEYCHAIN_PATH" | grep -qE "\) "; then
            echo "No codesigning identity found in keychain after import."
            exit 1
          fi

      - name: ðŸ“„ Decode provisioning profile (IOS_PROFILE_BASE64)
        shell: bash
        run: |
          set -euo pipefail

          if; then
            echo "IOS_PROFILE_BASE64 is empty. Set it in GitHub Secrets."
            exit 1
          fi

          PP_DIR="$HOME/Library/MobileDevice/Provisioning Profiles"
          mkdir -p "$PP_DIR"

          PP_FILE="$RUNNER_TEMP/profile.mobileprovision"
          export PP_FILE

          python3 - <<'PY'
          import os, re, base64, sys
          s = os.environ.get("IOS_PROFILE_BASE64", "")
          s = re.sub(r"\s+", "", s)
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in IOS_PROFILE_BASE64:", e)
            sys.exit(2)
          out = os.environ["PP_FILE"]
          with open(out, "wb") as f:
            f.write(data)
          print("profile bytes:", len(data))
          if len(data) < 500:
            print("Decoded provisioning profile is suspiciously small (<500 bytes).")
            sys.exit(3)
          PY

          /usr/bin/security cms -D -i "$PP_FILE" > "$PROFILE_PLIST"

          UUID=$(/usr/libexec/PlistBuddy -c 'Print:UUID' "$PROFILE_PLIST")
          NAME=$(/usr/libexec/PlistBuddy -c 'Print:Name' "$PROFILE_PLIST")

          cp "$PP_FILE" "$PP_DIR/$UUID.mobileprovision"

          echo "PROFILE_UUID=$UUID" >> "$GITHUB_ENV"
          echo "PROFILE_NAME=$NAME" >> "$GITHUB_ENV"
          echo "Imported provisioning profile: $NAME ($UUID)"

      - name: ðŸ”‘ Decode App Store Connect API key (p8)
        shell: bash
        run: |
          set -euo pipefail

          if; then
            echo "APP_STORE_CONNECT_API_KEY_BASE64 is empty. Set it in GitHub Secrets."
            exit 1
          fi
          if ||; then
            echo "APP_STORE_CONNECT_API_KEY_ID / APP_STORE_CONNECT_API_KEY_ISSUER_ID missing."
            exit 1
          fi

          mkdir -p "$ASC_DIR"
          ASC_P8_PATH="$ASC_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"
          export ASC_P8_PATH

          python3 - <<'PY'
          import os, re, base64, sys
          s = os.environ.get("APP_STORE_CONNECT_API_KEY_BASE64", "")
          s = re.sub(r"\s+", "", s)
          try:
            data = base64.b64decode(s, validate=True)
          except Exception as e:
            print("Invalid base64 in APP_STORE_CONNECT_API_KEY_BASE64:", e)
            sys.exit(2)
          out = os.environ
          with open(out, "wb") as f:
            f.write(data)
          print("p8 bytes:", len(data))
          if len(data) < 100:
            print("Decoded.p8 key is suspiciously small (<100 bytes).")
            sys.exit(3)
          PY

          chmod 600 "$ASC_P8_PATH"
          echo "ASC_API_KEY_PATH=$ASC_P8_PATH" >> "$GITHUB_ENV"

      - name: ðŸ—ï¸ Build archive (xcodebuild archive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$ARCHIVE_PATH"

          set +o pipefail
          if; then
            xcodebuild \
              -workspace "$XCODE_WORKSPACE" \
              -scheme "$XCODE_SCHEME" \
              -configuration "$CONFIGURATION" \
              -sdk iphoneos \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
              archive 2>&1 | tee "$XCODEBUILD_ARCHIVE_LOG" | eval "$XCPRETTY_CMD"
            XC=${PIPESTATUS}
          else
            xcodebuild \
              -workspace "$XCODE_WORKSPACE" \
              -scheme "$XCODE_SCHEME" \
              -configuration "$CONFIGURATION" \
              -sdk iphoneos \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
              archive 2>&1 | tee "$XCODEBUILD_ARCHIVE_LOG"
            XC=${PIPESTATUS}
          fi
          set -o pipefail

          if [ "${XC:-1}" -eq 0 ] &&; then
            echo "Archive directory missing at $ARCHIVE_PATH"
            exit 1
          fi
          exit $XC

      - name: ðŸ§¾ Create ExportOptions.plist (App Store / TestFlight)
        shell: bash
        run: |
          set -euo pipefail

          python3 - <<'PY'
          import os, plistlib

          # Minimalist ExportOptions to prevent Xcode 16 plist parsing errors
          export_options = {
            "method": "app-store",
            "teamID": os.environ,
            "signingStyle": "manual",
            "provisioningProfiles": {
              os.environ: os.environ
            },
            "uploadSymbols": True,
          }

          with open(os.environ, "wb") as f:
            plistlib.dump(export_options, f)
          PY

          /usr/bin/plutil -lint "$EXPORT_OPTIONS_PLIST"

      - name: ðŸ“¤ Export IPA (xcodebuild -exportArchive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$EXPORT_DIR"
          mkdir -p "$EXPORT_DIR"

          # FIX: Explicitly pass code signing arguments and set up command execution with eval
          XCODE_EXPORT_OVERRIDES='CODE_SIGN_IDENTITY="Apple Distribution" CODE_SIGN_STYLE=Manual'

          # Get command for xcpretty
          XCPRETTY_COMMAND="${XCPRETTY_CMD:-}"

          # Construct the base xcodebuild command
          XCODEBUILD_CMD="xcodebuild -exportArchive -archivePath \"$ARCHIVE_PATH\" -exportPath \"$EXPORT_DIR\" -exportOptionsPlist \"$EXPORT_OPTIONS_PLIST\" $XCODE_EXPORT_OVERRIDES"

          set +o pipefail
          # The use of 'eval' here is to correctly execute the pipe for xcpretty/tee when conditionally included.
          if; then
            # Run with xcpretty
            eval "$XCODEBUILD_CMD 2>&1 | tee \"$XCODEBUILD_EXPORT_LOG\" | $XCPRETTY_COMMAND"
            XC=${PIPESTATUS}
          else
            # Run without xcpretty
            eval "$XCODEBUILD_CMD 2>&1 | tee \"$XCODEBUILD_EXPORT_LOG\""
            XC=${PIPESTATUS}
          fi
          set -o pipefail

          if [ "${XC:-1}" -eq 0 ]; then
            ls -la "$EXPORT_DIR"
            # Ensure IPA exists
            test -n "$(find "$EXPORT_DIR" -maxdepth 1 -name "*.ipa" -print -quit)"
          fi

          exit $XC

      - name: ðŸš€ Upload to TestFlight (fastlane pilot)
        shell: bash
        env:
          RELEASE_NOTES: ${{ inputs.release_notes }}
        run: |
          set -euo pipefail

          IPA_PATH=$(find "$EXPORT_DIR" -maxdepth 1 -name "*.ipa" | head -n 1)

          python3 - <<'PY'
          import os, json
          with open(os.environ, "r", encoding="utf-8") as f:
            key = f.read()
          payload = {
            "key_id": os.environ,
            "issuer_id": os.environ,
            "key": key,
            "in_house": False
          }
          with open(os.environ, "w", encoding="utf-8") as f:
            json.dump(payload, f)
          PY

          if [ "${{ steps.ruby.outputs.use_bundler }}" = "true" ]; then
            bundle exec fastlane pilot upload \
              --api_key_path "$ASC_API_KEY_JSON" \
              --ipa "$IPA_PATH" \
              --skip_waiting_for_build_processing true \
              --changelog "$RELEASE_NOTES"
          else
            fastlane pilot upload \
              --api_key_path "$ASC_API_KEY_JSON" \
              --ipa "$IPA_PATH" \
              --skip_waiting_for_build_processing true \
              --changelog "$RELEASE_NOTES"
          fi

      - name: ðŸ“Ž Upload build artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: ios-build-artifacts
          path: |
            ${{ env.EXPORT_OPTIONS_PLIST }}
            ${{ env.PROFILE_PLIST }}
            ${{ env.ARCHIVE_INFO_PLIST }}
            ${{ env.ARCHIVE_PATH }}
            ${{ env.EXPORT_DIR }}
            ${{ env.XCODEBUILD_ARCHIVE_LOG }}
            ${{ env.XCODEBUILD_EXPORT_LOG }}

      - name: ðŸ§¹ Cleanup keychain
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if &&; then
            security delete-keychain "$KEYCHAIN_PATH" |

| true
          fi
