name: iOS Manual Deploy (App Store Connect / TestFlight)

on:
  workflow_dispatch:
    inputs:
      release_notes:
        description: "Release notes for TestFlight (optional)"
        required: false
        default: ""

jobs:
  ios_manual_deploy:
    runs-on: macos-14
    timeout-minutes: 60

    env:
      APPLE_ID: ${{ secrets.APPLE_ID }}
      APP_IDENTIFIER: ${{ secrets.APP_IDENTIFIER }}
      APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

      APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
      APP_STORE_CONNECT_API_KEY_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ISSUER_ID }}
      APP_STORE_CONNECT_API_KEY_BASE64: ${{ secrets.APP_STORE_CONNECT_API_KEY_BASE64 }}

      IOS_DIST_CERT_BASE64: ${{ secrets.IOS_DIST_CERT_BASE64 }}
      IOS_DIST_CERT_PASSWORD: ${{ secrets.IOS_DIST_CERT_PASSWORD }}

      IOS_PROFILE_BASE64: ${{ secrets.IOS_PROFILE_BASE64 }}
      KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}

      XCODE_WORKSPACE: ios/JunoNative.xcworkspace
      XCODE_SCHEME: JunoNative
      CONFIGURATION: Release
      NODE_VERSION: "22"

    steps:
      - name: ðŸ§¾ Checkout code
        uses: actions/checkout@v4

      - name: Compute build paths
        shell: bash
        run: |
          set -euo pipefail
          echo "EXPORT_OPTIONS_PLIST=$RUNNER_TEMP/ExportOptions.plist" >> "$GITHUB_ENV"
          echo "ARCHIVE_PATH=$RUNNER_TEMP/JunoNative.xcarchive" >> "$GITHUB_ENV"
          echo "ARCHIVE_INFO_PLIST=$RUNNER_TEMP/JunoNative.xcarchive/Info.plist" >> "$GITHUB_ENV"
          echo "EXPORT_DIR=$RUNNER_TEMP/build" >> "$GITHUB_ENV"
          echo "ASC_DIR=$RUNNER_TEMP/asc" >> "$GITHUB_ENV"
          echo "ASC_API_KEY_JSON=$RUNNER_TEMP/api_key.json" >> "$GITHUB_ENV"
          echo "PROFILE_PLIST=$RUNNER_TEMP/profile.plist" >> "$GITHUB_ENV"

      - name: ðŸ§  Detect JS package manager (Option B)
        id: pm
        shell: bash
        run: |
          set -euo pipefail
          if [ -f "yarn.lock" ]; then
            echo "manager=yarn" >> "$GITHUB_OUTPUT"
          elif [ -f "package-lock.json" ]; then
            echo "manager=npm" >> "$GITHUB_OUTPUT"
          elif [ -f "pnpm-lock.yaml" ]; then
            echo "manager=pnpm" >> "$GITHUB_OUTPUT"
          else
            echo "manager=yarn" >> "$GITHUB_OUTPUT"
          fi

      - name: ðŸŸ© Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: ðŸ“¦ Install JS deps (lockfile-aware)
        shell: bash
        run: |
          set -euo pipefail
          corepack enable || true
          case "${{ steps.pm.outputs.manager }}" in
            yarn)
              if [ -f "yarn.lock" ]; then yarn install --frozen-lockfile; else yarn install; fi
              ;;
            npm)
              if [ -f "package-lock.json" ]; then npm ci; else npm install; fi
              ;;
            pnpm)
              pnpm --version || corepack prepare pnpm@latest --activate
              if [ -f "pnpm-lock.yaml" ]; then pnpm install --frozen-lockfile; else pnpm install; fi
              ;;
          esac

      - name: ðŸ’Ž Setup Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: "3.2"
          bundler-cache: false

      - name: ðŸ’Ž Install fastlane/cocoapods/xcpretty
        shell: bash
        run: |
          set -euo pipefail
          gem install fastlane cocoapods xcpretty -N
          echo "$(ruby -e 'print Gem.bindir')" >> "$GITHUB_PATH"
          xcpretty --version || echo "âš ï¸ xcpretty not found after install!"

      - name: ðŸ§° Install CocoaPods
        shell: bash
        run: |
          set -euo pipefail
          cd ios
          pod install --repo-update

      - name: ðŸ” Create temporary keychain
        shell: bash
        run: |
          set -euo pipefail
          KEYCHAIN_PATH="$RUNNER_TEMP/ios-build.keychain-db"
          KEYCHAIN_PASSWORD="${KEYCHAIN_PASSWORD:-temp-pass}"
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security list-keychains -d user -s "$KEYCHAIN_PATH" "$HOME/Library/Keychains/login.keychain-db"
          security default-keychain -s "$KEYCHAIN_PATH"
          echo "KEYCHAIN_PATH=$KEYCHAIN_PATH" >> "$GITHUB_ENV"
          echo "KEYCHAIN_PASSWORD=$KEYCHAIN_PASSWORD" >> "$GITHUB_ENV"

      - name: ðŸªª Import signing certificate (p12)
        shell: bash
        run: |
          set -euo pipefail
          CERT_P12="$RUNNER_TEMP/ios_dist.p12"
          python3 -c "import base64,os; open('${CERT_P12}','wb').write(base64.b64decode(os.environ['IOS_DIST_CERT_BASE64'].strip()))"
          security import "$CERT_P12" -k "$KEYCHAIN_PATH" -P "$IOS_DIST_CERT_PASSWORD" \
            -T /usr/bin/codesign -T /usr/bin/xcodebuild
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

      - name: ðŸ“„ Decode provisioning profile (IOS_PROFILE_BASE64)
        shell: bash
        run: |
          set -euo pipefail
          PP_FILE="$RUNNER_TEMP/profile.mobileprovision"
          python3 -c "import base64,os; open('${PP_FILE}','wb').write(base64.b64decode(os.environ['IOS_PROFILE_BASE64'].strip()))"
          /usr/bin/security cms -D -i "$PP_FILE" > "$PROFILE_PLIST"
          UUID=$(/usr/libexec/PlistBuddy -c 'Print:UUID' "$PROFILE_PLIST")
          NAME=$(/usr/libexec/PlistBuddy -c 'Print:Name' "$PROFILE_PLIST")
          mkdir -p "$HOME/Library/MobileDevice/Provisioning Profiles"
          cp "$PP_FILE" "$HOME/Library/MobileDevice/Provisioning Profiles/$UUID.mobileprovision"
          echo "PROFILE_NAME=$NAME" >> "$GITHUB_ENV"

      - name: ðŸ”‘ Decode App Store Connect API key (p8)
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$ASC_DIR"
          ASC_P8_PATH="$ASC_DIR/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"
          python3 -c "import base64,os; open('${ASC_P8_PATH}','wb').write(base64.b64decode(os.environ['APP_STORE_CONNECT_API_KEY_BASE64'].strip()))"
          chmod 600 "$ASC_P8_PATH"
          echo "ASC_API_KEY_PATH=$ASC_P8_PATH" >> "$GITHUB_ENV"

      - name: ðŸ—ï¸ Ensure xcpretty available
        shell: bash
        run: |
          set -euo pipefail
          echo "$(ruby -e 'print Gem.bindir')" >> "$GITHUB_PATH"
          if ! command -v xcpretty >/dev/null 2>&1; then
            gem install xcpretty -N
          fi

      - name: ðŸ—ï¸ Build archive (xcodebuild archive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$ARCHIVE_PATH"
          if command -v xcpretty >/dev/null 2>&1; then
            xcodebuild \
              -workspace "$XCODE_WORKSPACE" \
              -scheme "$XCODE_SCHEME" \
              -configuration "$CONFIGURATION" \
              -sdk iphoneos \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
              archive | xcpretty
          else
            xcodebuild \
              -workspace "$XCODE_WORKSPACE" \
              -scheme "$XCODE_SCHEME" \
              -configuration "$CONFIGURATION" \
              -sdk iphoneos \
              -archivePath "$ARCHIVE_PATH" \
              -destination "generic/platform=iOS" \
              DEVELOPMENT_TEAM="$APPLE_TEAM_ID" \
              archive
          fi
          test -d "$ARCHIVE_PATH"

      - name: ðŸ§¾ Create ExportOptions.plist (App Store)
        shell: bash
        run: |
          set -euo pipefail
          python3 - <<'PY'
          import os, plistlib
          bundle_id = os.environ["APP_IDENTIFIER"]
          team_id = os.environ["APPLE_TEAM_ID"]
          profile_name = os.environ["PROFILE_NAME"]
          data = {
            "method": "app-store",
            "destination": "export",
            "signingStyle": "manual",
            "stripSwiftSymbols": True,
            "compileBitcode": False,
            "teamID": team_id,
            "provisioningProfiles": {bundle_id: profile_name}
          }
          with open(os.environ["EXPORT_OPTIONS_PLIST"], "wb") as f:
            plistlib.dump(data, f)
          PY
          plutil -lint "$EXPORT_OPTIONS_PLIST"

      - name: ðŸ“¤ Export IPA (xcodebuild -exportArchive)
        shell: bash
        run: |
          set -euo pipefail
          rm -rf "$EXPORT_DIR"; mkdir -p "$EXPORT_DIR"
          if command -v xcpretty >/dev/null 2>&1; then
            xcodebuild \
              -exportArchive \
              -archivePath "$ARCHIVE_PATH" \
              -exportPath "$EXPORT_DIR" \
              -exportOptionsPlist "$EXPORT_OPTIONS_PLIST" | xcpretty
          else
            xcodebuild \
              -exportArchive \
              -archivePath "$ARCHIVE_PATH" \
              -exportPath "$EXPORT_DIR" \
              -exportOptionsPlist "$EXPORT_OPTIONS_PLIST"
          fi
          ls -la "$EXPORT_DIR"
          test -n "$(find "$EXPORT_DIR" -maxdepth 1 -name '*.ipa' -print -quit)"

      - name: ðŸš€ Upload to TestFlight
        shell: bash
        env:
          RELEASE_NOTES: ${{ inputs.release_notes }}
        run: |
          set -euo pipefail
          IPA_PATH=$(find "$EXPORT_DIR" -maxdepth 1 -name '*.ipa' | head -n 1)
          python3 - <<'PY'
          import os, json
          key_path = os.environ["ASC_API_KEY_PATH"]
          key = open(key_path).read()
          payload = {
            "key_id": os.environ["APP_STORE_CONNECT_API_KEY_ID"],
            "issuer_id": os.environ["APP_STORE_CONNECT_API_KEY_ISSUER_ID"],
            "key": key,
            "in_house": False
          }
          json.dump(payload, open(os.environ["ASC_API_KEY_JSON"], "w"))
          PY
          fastlane pilot upload \
            --api_key_path "$ASC_API_KEY_JSON" \
            --ipa "$IPA_PATH" \
            --skip_waiting_for_build_processing true \
            --changelog "$RELEASE_NOTES"

      - name: ðŸ§¹ Cleanup keychain
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          if [ -n "${KEYCHAIN_PATH:-}" ] && [ -f "$KEYCHAIN_PATH" ]; then
            security delete-keychain "$KEYCHAIN_PATH" || true
          fi
